"Note","Course","Module","Clip","Time in Clip","URL"
"What is Java? Java is:\n1 - a programming language\n2 - a runtime environment (JRE/ Java SE- Standard Edition)","Java Fundamentals: The Core Platform","Introduction","The Role of the Java Core Platform","0:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m1&clip=1&mode=live&start=5.442012&noteid=a4fd72b1-9e7c-40b1-bc8f-82e27c3e196b"
"Android:\n- a Java-based environment, but it's provided by Google, and it's developed separately from the other Java environments","Java Fundamentals: The Core Platform","Introduction","The Role of the Java Core Platform","2:59","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m1&clip=1&mode=live&start=179.898533&noteid=46400fba-14f4-483e-b790-50b8c889c506"
"Java EE- Enterprise Edition, is built on top of the JRE","Java Fundamentals: The Core Platform","Introduction","The Role of the Java Core Platform","4:07","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m1&clip=1&mode=live&start=247.789114&noteid=5ea56485-65be-497c-9ae8-6b89c4cefa03"
"Streams:\n- a stream is an ordered sequence of data\n  - it provides a common I/O model\n  - abstracts details of underlying source or destination\n  - stream types are unidirectional: you're either going to read to the stream or write to the stream; no single stream does both\n- 2 categories of streams:\n  - Byte Streams\n    - interact as binary data\n  - Text Streams:\n    - interact as Unicode characters\n- in general interaction is the same for both stream types","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Streams Overview","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=1&mode=live&start=1.14025&noteid=d71da3d9-a1b8-4629-afc2-f26c2f46f778"
"Read-From Streams:\n- Base class for reading from binary data is a class called InputStream\n- Base class for reading from text data is called Reader\n- both have a read() method that returns an int\n  - as long as the int returned is >=0, you have not reached the end of the stream","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=2.453444&noteid=203e74c8-0d03-4b0e-8bc3-17a1cdfdfa49"
"Reading One Byte at a Time:\nInputStream input = // create input stream\nint intVal;\nwhile((intVal = input.read())>=0){\n  byte byteVal = (byte) intVal;\n// do something with byteVal\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","1:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=75.975078&noteid=7ebdaf46-4342-441a-bd44-200d94f433f0"
"Reading One Character at a Time:\nReader reader = // create reader\nint intVal;\nwhile((intVal = reader.read())>=0){\n char charVal = (char) intVal;\n// do something with charVal\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","1:53","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=113.937622&noteid=12d43cd3-2b60-46e2-9d56-c4d59e043173"
"Reading Arrays:\n- InputStream has a method:\n - int read(byte[] buff): it''ll read all the bytes that will fit into that array\n- Reader has a method:\n - int read(char [] buff): it''ll read all the characters that will fit into the character array\n- both methods return an int, but in this case the int returned represents the number of bytes/chars ACTUALLY read (since the array isn't necessarily full). But it will still return a -1 at the end of the stream.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","3:16","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=196.676978&noteid=827d93f1-f5ca-4115-af35-ef0be4c0d207"
"Reading Array of Bytes:\nInputStream input = // create input stream\nint length;\nbyte[] byteBuff = new byte[10] //this is the array that we want to read into\nwhile((length = input.read(byteBuff))>=0){\nfor(int i=0;i<length;i++){\n byte byteVal = byteBuff[i];\n// do something with byteVal\n  }\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","3:16","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=196.676978&noteid=0d4c3f67-32ca-4c5f-b262-1b0b5fa63674"
"Reading Array of Characters:\nReader reader = // create reader\nint length;\nchar[] charBuff = new char[10] //this is the array that we want to read into\nwhile((length = reader.read(charBuff))>=0){\nfor(int i=0;i<length;i++){\nchar charVal = charBuff[i];\n// do something with charVal\n }\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","4:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=241.035413&noteid=d5e9306f-6080-464f-9470-ca4350ace0c8"
"Write-To Streams:\n- Base class for writing binary data is OutputStream\n  -  it has the methods:\n    - void write(int b): b is an individual byte that you want to write (you can pass a byte into this method)\n    - void write(byte[] buff): buff is an array of bytes that you want to write\n- Base class for writing to text data is Writer\n  - it has the methods:\n    - void write(int ch): ch is an individual char you want to write\n    - void write(char[] buff): buff is an array of chars you want to write\n    - void write(String str): str is a string of chars you want to write","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","4:31","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=271.920768&noteid=673a31af-e5e4-4917-9b46-cecb4f26820a"
"Writing Bytes:\n\nOutputStream output = // create output stream\nbyte byteVal = 100;\noutput.write(byteVal);\n\nWriting Byte Array:\nbyte[] byteBuff = {0, 63, 127};\noutput.write(byteBuff);","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","4:53","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=293.410579&noteid=8781e9d6-5d37-41db-955d-40a2a4285010"
"Writing Characters:\n\nWriter writer = // create output stream\nchar charVal = 'a';\nwriter.write(charVal);\n\nWriting Char Array:\nchar[] charBuff = {'a', 'b', 'c'};\nwriter.write(charBuff);\n\nWriting String:\nString stringVal = ""Hello World"";'\nwriter.write(stringVal);\n","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Reading and Writing with Streams","5:32","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=2&mode=live&start=332.574502&noteid=ea3e778b-100a-4ea9-913c-252a4cd318be"
"Common Input/OutputStream Derived Classes:\n\n- InputStream splits into:\n  - ByteArrayInputStream: allows you to create a stream over a byte array.\n  - PipedInputStream: one part of your program can use the PipedInputStream, and then read that content back out. Take care of coordinating what's been read and where things have been written. Works well for producer/consumer concept.\n  - FileInputStream: allow us to create streams over files\n\n\n- OutputStream splits into:\n  - ByteArrayOutputStream: allows you to create a stream over a byte array.\n  - PipedOutputStream: one part of your program can use the PipedOutputStream and write content into it. Take care of coordinating what's been read and where things have been written. Works well for producer/consumer concept.\n  - FileOutputStream: allow us to create streams over files\n","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Common Stream Classes","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=3&mode=live&start=0&noteid=031c189d-10eb-45c3-bd37-1eed0aa2354b"
"Common Reader/Writer Derived Classes:\n\n- Reader splits into:\n  - charArrayReader: allows us to create a char array and put streams over them\n  - StringReader: allows us to work with a stringBuffer and put streams over them\n  - PipedReader: gives us that producer/consumer relationship over text content (consumer)\n  - InputStreamReader: allows us to create a Reader over an InputStream\n\n\n- Writer splits into:\n  - charArrayWriter: allows us to create a char array and put streams over them\n  - StringWriter: allows us to work with a stringBuffer and put streams over them\n  - PipedWriter: gives us that producer/consumer relationship over text content (producer)\n - OutputStreamWriter: allows us to create a Writer over an OutputStream","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Common Stream Classes","1:18","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=3&mode=live&start=78.627174&noteid=142e77ec-765a-4734-8aba-b9edb63ecf37"
"- InputStreamReader splits into:\n  - FileReader: allow us to have file-based content with a reader over the top of those\n\n\n- OutputStreamWriter splits into:\n  - FileWriter: allow us to have file-based content with a writer over the top of those","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Common Stream Classes","2:32","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=3&mode=live&start=152.329373&noteid=e0940559-a189-42ad-92ee-0aaade863073"
"Stream Realities:\n- Error handling: stream methods throw exceptions to indicate errors\n- Cleanup: cannot rely on standard Java resource recovery to clean up streams\n  - Streams are backed by physical storage\n    - very often that storage exists outside the Java runtime\n    - so in those cases the Java Resource Recovery, the garbage collector, can't really be relied on to clean those things up in a timely fashion\n  - Providing Reliable Cleanup:\n    - Streams implement the Closeable interface, which contains one method: close(), which we are responsible for calling","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Stream Errors and Cleanup","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=4&mode=live&start=1.185743&noteid=075dac72-676b-43d9-b961-38ef41f0e00b"
"Automating Cleanup (so we don't have to keep catching exceptions):\n- AutoCloseable interface\n  - has 1 method: close()\n    - interface AutoCloseable{\nvoid close() throws Exception;\n}\n  - base interface of the Closeable interface\n    - interface Closeable extends AutoCloseable{\nvoid close() throws IOException;\n}\n  - by a type implementing the AutoCloseable interface, it provides support for this try-with-resources\n  - because Streams implement the Closeable interface, this means they also implement the AutoCloseable interface","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Stream Errors and Cleanup","2:31","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=4&mode=live&start=151.782489&noteid=2f2af607-85dd-450d-8aa3-51cef61dee7a"
"Try-with-resources:\n- automates the cleanup of 1 or more resources\n  - a resource is any type that implements AutoCloseable\n- syntax similar to a traditional try statement\n- optionally includes catch block(s)\n  - catch blocks will handle any errors that occur inside the try block or try-with-resources, but it will also handle the errors that are thrown in a call to close.\n  - meaning that with try-with-resources, the catch blocks can handle errors on codes that we explicitly call, but they can also handle errors on code that we did not explicitly call, which is the close() method, which is called first automatically.\n- Example:\n    public static void doTryWithResources() {\n        char[] buff = new char[8];\n        int length;\n        try (Reader reader = Helper.openReader(""file1.txt"")) {\n            while((length = reader.read(buff)) >= 0) {\n                System.out.println(""\nlength: "" + length);\n                for(int i=0; i < length; i++)\n                    System.out.print(buff[i]);\n            }\n        } catch(IOException e) {\n            System.out.println(e.getClass().getSimpleName() + "" - "" + e.getMessage());\n        }\n    }\n  - by creating the instance of the Reader INSIDE the parentheses of the try block, this takes care of identifying that we want to have this resource automatically closed, and therefore we don't need to declare ""Reader reader = null;"" in the beginning and we also don't need the following code (that would usually come at the end):\nfinally {\n            try {\n                if (reader != null)\n                    reader.close();\n            } catch(IOException e2) {\n                System.out.println(e2.getClass().getSimpleName() + "" - "" + e2.getMessage());\n            }\n        }","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Stream Errors and Cleanup","3:14","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=4&mode=live&start=194.966587&noteid=08bd9c02-cd0b-4a8d-ae73-999d0dbcfebe"
"Try-with-resources can also work on and automatically close multiple resources:\n- Example (copying one file into another, which means we're using a Reader for the first file and a Writer for the second file):\n    public static void doTryWithResourcesMulti() {\n        char[] buff = new char[8];\n        int length;\n        try (Reader reader = Helper.openReader(""file1.txt"");\n             Writer writer = Helper.openWriter(""file2.txt""))  {\n            while((length = reader.read(buff)) >= 0) {\n                System.out.println(""\nlength: "" + length);\n                writer.write(buff, 0, length);\n            }\n        } catch(IOException e) {\n            System.out.println(e.getClass().getSimpleName() + "" - "" + e.getMessage());\n        }\n    }","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Demo: Working with Try-with-resources Part 1","3:07","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=5&mode=live&start=187.551332&noteid=4cfb1de8-db99-46fd-bad9-a65ab2b50117"
"Notes about try-with-resources:\n- even if there is no explicit call to close() in the code, close() gets called AUTOMATICALLY\n- the catch block handles the call to close, so even if we never explicitly call close(), the catch block we put in place still handles the exception that's being thrown by close\n- if more than 1 exception is thrown, only the initial exception will be shown, while the others are SUPPRESSED, but you can use e.getSuppressed() to get the other exceptions that were captured.\n  - e.getSuppressed() returns a collection of suppressed exceptions, so to see all of them you can use the following code:\n\n\n for(Throwable t :e.getSuppressed())\n                System.out.println(""Suppressed: "" + t.getMessage());\n        }","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Demo: Working with Try-with-resources Part 2","1:35","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=6&mode=live&start=95.992433&noteid=3d06c3dc-3d42-48d9-9a83-1b63a2c6d645"
"Chaining Streams:\n- Streams are often chained together\n  - one stream instance leverages another\n  - creates higher-level functionality\n  - simplifies reusability by allowing each stream to specialize in a specific task\n  -  we chain using the constructor:\n    - when we construct the higher level instance of the stream, we pass in an instance of the lower level instance of the stream.\n- Example: InputStreamReader leverages chaining:\n  - Reader behavior over InputStream\n  - Character behavior over binary: allows it to have data that comes in in a binary format and allows us to process it as character data.\n- Can create your own ""high-level"" streams\n  - most commonly chain similarly typed streams (chain a reader over a reader, etc)\n-  Java provides classes that can be used to simplify the process of creating specialized streams.\n  - FilterReader, FilterWriter, FilterInputStream, FilterOutputStream\n    - these are abstract classes\n    - make it easy for us to provide specialization because they accept in a reference to another stream, and then all of the methods in these classes simply call the contained streams' methods.\n    - allows us to focus on the customization that we want to provide -> so we only have to override those methods where we want to do something different than what the contained stream does","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Chaining Streams","0:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=7&mode=live&start=5.214347&noteid=d38ca98b-e4e7-4cd2-a027-8e5635441620"
"Chaining Streams Example:\n\nvoid doChain(InputStream in) throws IOException {\nint length;\nchar[] charBuff = new char[128];\ntry (InputStreamReader rdr = new InputStreamReader(in)) {\nwhile((length = rdr.read(charBuff)) >= 0) {\n// do something with charBuff\n}\n}\n}\n\n- Notice that when the InputStreamReader is constructed, the reference to the InputStream is passed in\n  - the InputStreamReader knows that binary data is coming in, and it will convert it so I can work with it as character data\n\n\n- Chaining: building one layer on top of another\n\n- Note that the InputStreamReader class is defined such that when close() is called on it, the InputStream class is also closed\n\n- Common scenario when chaining streams together: closing the higher level stream closes the contained streams as well","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Chaining Streams","1:21","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=7&mode=live&start=81.414943&noteid=4b25a387-3663-4d1e-89ed-5bbcdb5f1921"
"Accessing Files:\n- often use streams for file-based I/O\n- there's a class for each stream type in java.io package\n  - FileReader\n  - FileWriter\n  - FileInputStream\n  - FileOutputStream\n  - Note that these classes are all deprecated, but are still widely used in code.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=0.800089&noteid=c6ad88f1-d10c-4923-a456-988ff0cdfaf1"
"Buffered Streams:\n- when we're interacting with files, we generally don't wanna interact with them directly.\n- direct file access can be inefficient\n- the buffered streams can improve efficiency of interacting with files because they buffer the content in memory\n  - allows you to perform reads/writes in large chunks\n  - reduces the interaction with the underlying stream\n- used mostly with file-based streams, but can be used with other streams as well\n- Buffering available for all 4 stream types\n  - BufferedReader\n  - BufferedWriter\n  - BufferedInputStream\n  - BufferedOutputStream\n","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","0:42","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=42.115004&noteid=a9aa4b02-d543-4cd0-a565-ff2cd9f621c0"
"Buffered Streams:\n\ntry (BufferedReader br =\nnew BufferedReader(new FileReader(“file1.txt”))) {\nint intVal;\nwhile((intVal = br.read()) >= 0) {\nchar charVal = (char) intVal;\n// do something with charVal\n}\n}\n- there's no extra work from my standpoint in terms of using the buffered streams, it's just important to go ahead and use them especially with files to improve that efficiency.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","2:04","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=124.088084&noteid=72509e7f-5010-4820-b15b-3a51c0c31c62"
"Buffered Streams & Line Breaks:\n- buffered streams are also intelligent about line breaks\n- line breaks vary across platforms\n  - Unix: \n (new line)\n  - Windows: \r\n ( carriage return & new line)\n- buffered streams add line break support\n  - use the correct value for the current platform\n- BufferedWriter has a method called newLine(), which writes the appropriate newLine for the platform.\n- BufferedReader understands each platform's newLine characters, and allows you to read entire lines at one time with the ReadLine() method, and it will pass the line back to you in a string.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","2:13","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=133.70258&noteid=505eced8-a6b9-4fd5-9dc5-7efe361154ab"
"Writing with Line Breaks:\n\nvoid writeData(String[] data) throws IOException {\ntry (BufferedWriter bw =\nnew BufferedWriter(new FileWriter(“data.txt”))) {\nfor(String d:data) {\nbw.write(d);\nbw.newline();\n}\n}\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","3:24","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=204.393042&noteid=09697f13-6cf3-410a-bbd3-7bfe09c74e2e"
"Reading Lines:\n\nvoid readData() throws IOException {\ntry (BufferedReader br =\nnew BufferedReader(new FileReader(“data.txt”))) {\nString inValue;\nwhile((inValue = br.readLine()) != null) {\nSystem.out.println(inValue);\n}\n}\n}\n\n- Line-level behavior is one of the real values of the BufferedReader\n- Note: when using readLine(), the end of the file is indicated when null is returned\n","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","File and Buffered Streams","4:13","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=8&mode=live&start=253.740294&noteid=fdd57778-e3e4-4fc5-abe0-88fd2c4a9b37"
"Accessing Files with the java.nio.file Package:\n- java.nio.file is the preferred package for files because FileReader, FileWriter, FileInputStream, and FileOutputStream (which are from the java.io package) are no deprecated\n  - that being said, you will still find them in a lot of code, but anything you write that's new will use these new types provide a number of benefits over the types in the java.io package\n  - IMPORTANT NOTE: It's only the file types that are deprecated:\n    - Deprecated: FileReader, FileWriter, FileInputStream, and FileOutputStream\n    - NOT Deprecated: InputStream, OutputStream, Reader, Writer, BufferedReader, BufferedWriter and other general stream types\n- so in any new file system work we do, we want to use these new types here.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=0.97172&noteid=6f1210ec-3b48-4b3a-88ca-44305cfad011"
"Benefits of java.nio package file types:\n- better exception reporting\n- greater scalability\n- more file system feature support\n- simplify common tasks","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","0:57","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=57.35259&noteid=ef7a80c2-0692-43c0-bf8f-f234ae8929aa"
"Path & Paths Type:\n\nPath\n- used to locate a file system item\n- can be a file or a directory\n\nPaths\n- we get a Path by using the Paths class\n- provides static Path factory methods for translating from the common representations of a file like the hierarchical path string or a URI into a Path object\n\nTwo Equally Legal Examples:\n- Path p1 = Paths.get(""\documents\data\foo.txt"");\n- Path p2 = Paths.get(""documents"",""data"",""foo.txt"");\n- the reference you get back, in this case p1 or p2, is a representation of that file. \n- Both p1 and p2 reference the SAME file system object.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","1:19","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=79.434471&noteid=03995527-fb54-4147-b549-4786bc1ab3f3"
"Files Type:\n\nFiles:\n- provides static methods for interacting with files\n- create, copy, delete, etc\n- gives us the ability to open up the file streams over the specific file:\n  - newBufferedReader\n  - newBufferedWriter\n  - newInputStream\n  - newOutputStream\n- provides convenience methods that let us do read/write file contents in a single statement\n  - readAllLines(): open a file, read all the lines in it, and then closes it (returns a List<String>)\n  - write(): open a file, write all the content out to it, and then closes it\n  - there's an mkdir() method that creates a directory based on the name you passed in!","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","2:21","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=141.142961&noteid=72900b25-afec-48e1-86e8-500244bcadc9"
"Reading Lines with BufferedReader (java.nio):\n\nvoid readData() throws IOException {\ntry (BufferedReader br =\nFiles.newBufferedReader(Paths.get(“data.txt”))) {\nString inValue;\nwhile((inValue = br.readLine()) != null) {\nSystem.out.println(inValue);\n}\n}\n}","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","3:19","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=199.078129&noteid=e078c736-d714-4750-9592-6ed3d30b9ad0"
"Read All Lines (java.nio):\n\nvoid readThemAll() throws IOException {\nList<String> lines =\nFiles.readAllLines(Paths.get((“data.txt”));\nfor(String line:lines)\nSystem.out.println(line);\n}\n\n- just make sure it's not too big of a file because List<String> lines will have to fit in memory, but it very much simplifies that process of doing something we do all the time, which is open a file and read through it.\n\n- there is a write method that works very much the same way","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Accessing Files with the java.nio.file Package","3:58","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=9&mode=live&start=238.534393&noteid=30311997-8517-4240-984e-c1d6c9289686"
"File Systems:\n- files are contained within a file system\n  - now most commonly when we work with files, we're working with a computer's default file system\n  - but Java also supports the concept of specialized file systems\n    - Example: ZIP file system - the ability to create and read files contained within a compressed ZIP file.\n  - Path instances are tied to a particular file system.\n    - the Paths class works only for the default file system\n    -  so we have to have some more general way of interacting with file systems and getting access to path instances within a file system, as follows:","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Using Default File System and Zip File Systems","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=10&mode=live&start=0.746901&noteid=734cc8a9-1c5d-4250-8105-e2df6bc8abcf"
"File System Types:\n\n- FileSystem:\n  - represents an individual file system\n  - contains the factory methods for creating Path instances within that file system.\n\n- FileSystems:\n  - we get a FileSystem by using the FileSystems class.\n  - it provides static factory methods or creating a file system,\n  - commonly when we open/create a FileSystem, we use the newFileSystem() method\n\n- but we need some way to identify a FileSystem.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Using Default File System and Zip File Systems","0:58","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=10&mode=live&start=58.068864&noteid=bd2c0df3-e2b6-4660-9333-e585037e24f5"
"Accessing File Systems:\n- the way we identify a FileSystem is by using Universal Resource Identifiers (URIs).\n  - a generalized way of identifying different resources, HTTP-based URLs, or one type of URI.\n  -  the specifics of a URI for a particular file system vary greatly between different FileSystem providers.\n    - the most common ones we work with are for the ZIP file system, which are identified by the URI scheme ""jar.file""\n      - Example: jar:file:/jimwilson/data/bar.zip\n      - that means that bar.zip is a file system contained within a directory data, contained within a directory jimwilson.\n- when we interact with a file system, each file system supports custom properties\n  - the specific properties vary depending on the file system provider\n  - Common Examples:\n    - whether to create if it doesn't exist\n    - when I'm interacting with it, what kind of string encoding is being used in that file system?","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Using Default File System and Zip File Systems","1:29","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=10&mode=live&start=89.51719&noteid=e9f30d05-7722-4fd8-b503-8c69b63c5c13"
"Creating a ZIP file:\n\n    public static void main(String[] args) {\n        String[] data = {\n                ""Line 1"",\n                ""Line 2 2"",\n                ""Line 3 3 3"",\n                ""Line 4 4 4 4"",\n                ""Line 5 5 5 5 5""\n        };\n\n        try(FileSystem zipFs = openZip(Paths.get(""myData.zip""))) {\n            copyToZip(zipFs);\n            writeToFileInZip1(zipFs, data);\n            writeToFileInZip2(zipFs, data);\n        } catch(Exception e) {\n            System.out.println(e.getClass().getSimpleName() + "" - "" + e.getMessage());\n        }\n    }System.out.println(e.getClass().getSimpleName() + "" - "" + e.getMessage());\n        }\n    }\n\n    private static FileSystem openZip(Path zipPath) throws IOException, URISyntaxException {\n        Map<String, String> providerProps = new HashMap<>();\n        providerProps.put(""create"", ""true"");\n\n        URI zipUri = new URI(""jar:file"", zipPath.toUri().getPath(), null);\n        FileSystem zipFs = FileSystems.newFileSystem(zipUri, providerProps);\n\n        return zipFs;\n    }\n\n Note:\n-  ""URI zipUri = new URI(""jar:file"", zipPath.toUri().getPath(), null);""\nbecause we want to make sure that it's fully qualified and formatted correctly for use in URI, so we convert the Path into a URI and then back into a Path\n","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Demo: Creating a Zip File System","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=11&mode=live&start=0.427295&noteid=361ec3c8-9c2d-484a-a4ee-5ff12acfa6ca"
"Copying and Writing to ZIP File:\n\n- Note: if you want to be at the root of the file, add a ""/"" to the front of your pathname\n\n    private static void copyToZip(FileSystem zipFs) throws IOException {\n        Path sourceFile = Paths.get(""file1.txt"");\n        //Path sourceFile = FileSystems.getDefault().getPath(""file1.txt"");\n        Path destFile = zipFs.getPath(""/file1Copied.txt"");\n\n        Files.copy(sourceFile, destFile, StandardCopyOption.REPLACE_EXISTING);\n    }\n\n    private static void writeToFileInZip1(FileSystem zipFs, String[] data) throws IOException {\n        try(BufferedWriter writer = Files.newBufferedWriter(zipFs.getPath(""/newFile1.txt""))) {\n            for(String d:data) {\n                writer.write(d);\n                writer.newLine();\n            }\n        }\n    }\n\n    private static void writeToFileInZip2(FileSystem zipFs, String[] data) throws IOException {\n        Files.write(zipFs.getPath(""/newFile2.txt""), Arrays.asList(data),\n                Charset.defaultCharset(), StandardOpenOption.CREATE);\n    }","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Demo: Copying and Writing Files to Zip File System","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=12&mode=live&start=2.912754&noteid=3737c7cc-206c-40c9-a26e-c01128c6e6ef"
"IMPORTANT:\nLook up the Java pages for Path, Paths, URI, File, Files, FileSystem, and FileSystems,StandardOpenOption, StandardCopyOption because there's a lot going on outside of this module.","Java Fundamentals: The Core Platform","Input and Output with Streams and Files","Summary","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m2&clip=13&mode=live&start=0.773026&noteid=395b2d18-0479-495c-b935-e59d40a0a670"
"More Powerful Solutions to Creating String Representations:\n- there exists the need for more powerful string creation\n  - concatenating strings is often not enough\n    - very focused on creation details; you basically kind of have to do every step to put things together.\n    - numeric conversions can be awkward\n  - StringBuilder has the same issues\n\n- Options for more powerful string creation\n  - StringJoiner\n    - simplifies joining a sequence of values\n  - String formatting\n    - use of format specifiers to specify desired appearance without dealing with creation details","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","More Powerful Solutions to Creating String Representations","0:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=1&mode=live&start=5.454139&noteid=29d6534f-0da1-499c-98bd-8ec9df6c43eb"
"StringJoiner:\n- StringJoiner has a very specific purpose:\n  - simpligy composing a string that is comprised of a sequence of values\n- How it works:\n  - Construct the StringJoiner\n    - specify string to separate your individual values\n    - optionally specify start/end strings\n  - Add values\n  - Retrieve the resulting string","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Joining Sequences of Values with StringJoiner","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=2&mode=live&start=2.249039&noteid=e29d34a3-64aa-4755-8571-daa61ba4b121"
"StringJoiner with Separator:\n\nStringJoiner sj = new StringJoiner("", "");\nsj.add(""alpha"");\nsj.add(""theta"");\nsj.add(""gamma"");\nString theResult = sj.toString();\n//theResult = ""alpha, theta, gamma""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Joining Sequences of Values with StringJoiner","1:03","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=2&mode=live&start=63.106644&noteid=9753ee47-7c9d-41da-8961-8b898813d9ca"
"StringJoiner Chaining Method Calls:\n\nStringJoiner sj = new StringJoiner("", "");\n\nsj.add(""alpha"").add(""theta"").add(""gamma"");\n\nString theResult = sj.toString();\n\n//theResult = ""alpha, theta, gamma""\n\nNote: \nBecause add() returns a reference to the StringJoiner, you can just chain the additions (or other relevant methods) as shown above, and the reslt will be identical to adding them all separately.\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Joining Sequences of Values with StringJoiner","1:04","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=2&mode=live&start=64.95693&noteid=dc1b3a5a-59e9-4ca8-b862-4fe8156bf5e4"
"StringJoiner with Start and End Values:\n\nFormat: new StringJoiner(separator, start_value, end_value)\n\nExample:\n\nStringJoiner sj = \nnew StringJoiner( "", "" ,  ""{"" ,  ""}"" );\n\nsj.add(""alpha"");\nsj.add(""theta"");\nsj.add(""gamma"");\nString theResult = sj.toString();\n\n//theResult= ""{alpha, theta, gamma}""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Joining Sequences of Values with StringJoiner","1:42","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=2&mode=live&start=102.734067&noteid=bb7ad6d0-906c-48c0-9ecc-f32da7ccac7f"
"StringJoiner with More Involved Separator:\n\nStringJoiner sj = \nnew StringJoiner(""], ["", ""["", ""]"");\nsj.add(""alpha"");\nsj.add(""theta"");\nsj.add(""gamma"");\nString theResult = sj.toString();\n\n//theResult = \n""[alpha], [theta], [gamma]""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Joining Sequences of Values with StringJoiner","2:17","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=2&mode=live&start=137.381787&noteid=695dcabd-e8b1-4ede-890f-1a6f803a2290"
"StringJoiner Edge Case Handling:\n\n- Edge Case 1: toString when only 1 value added\n  - when constructed with separator only\n    - returns only the added value\n  - when constructed with start/end strings\n    - returns string with that single value enclosed in the starting and ending strings\n  - Examples:\n\nHandling One Added Value Examples:\n\nStringJoiner sj1 = \nnew StringJoiner("", "");\nsj1.add(""alpha"");\nString theResult1 = sj1.toString();\n//theResult1 = ""alpha""\n\nStringJoiner sj2 = \nnew StringJoiner("", "", ""{"", ""}"");\nsj2.add(""alpha"");\nString theResult2 = sj2.toString();\n//theResult2 = ""{alpha}""\n\n- Edge Case 2: toString when no values added:\n  - when constructed with separator only\n    - returns empty string\n  - when constructed with start/end strings\n    - returns string with start/end only\n  - Can Customize Empty Handling:\n      - Can specify a special string for empty case\n        - specified with setEmptyValue method\n        - Note: a StringJoiner is considered empty only if the add method has NEVER been called.\n\n  - Examples:\n\nHandling No Added Values Examples:\n\nStringJoiner sj1 = \nnew StringJoiner("", "");\nString theResult1 = sj1.toString();\n//theResult2 = """" (empty string)\n\nStringJoiner sj2 = \nnew StringJoiner("", "", ""{"", ""}"");\nString theResult2 = sj2.toString();\n//theResult2 = ""{}""\n    \nCustomizing Empty Handling Examples:\n\nStringJoiner sj1 = \nnew StringJoiner("", "");\nsj1.setEmptyValue(""EMPTY"");\nString theResult1 = sj1.toString();\n//theResult1 = ""EMPTY""\n\nStringJoiner sj2 = \nnew StringJoiner("", "", ""{"", ""}"");\nsj2. setEmptyValue(""EMPTY"");\nString theResult2 = sj2.toString();\n//theResult2 = ""EMPTY""\n\nCustom Empty Handling Examples (shows that empty case means that add was NEVER called):\n\nStringJoiner sj1 = new StringJoiner("", "");\nsj1.setEmptyValue(""EMPTY"");\nsj1.add("""");\nString theResult1 = sj1.toString();\n//theResult1 = """" (empty string)\n\nStringJoiner sj2 = \nnew StringJoiner("", "", ""{"", ""}"");\nsj2. setEmptyValue(""EMPTY"");\nsj2.add("""");\nString theResult2 = sj2.toString();\n//theResult2 = ""{}""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","StringJoiner Edge Case Handling","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=3&mode=live&start=0.578382&noteid=20dfea97-bc82-4c88-9129-f56089f7c837"
"Constructing Strings with Format Specifiers:\n- Format Specifiers:\n  - Focus is on describing the desired result\n    - not concerned with the how\n  - format specifiers give us a lot of control over how things appear such as:\n    - positioning\n    - decimal places\n    - representation\n  - There are a number of different methods that support format specifiers:\n    - String.format\n    - System.out.printf\n    - Formatter.format\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Constructing String with Format Specifiers","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=4&mode=live&start=0.615654&noteid=cecef2ed-cfa5-48ec-9dd6-646ea2611f64"
"Concatenation vs. Formatting Example 1:\n\nint david = 13, dawson = 11, dillon = 4, gordon = 2;\n\n- Concatenation\nString s1 =\n""My nephews are "" + david + "", "" + dawson\n+ "", "" + dillon + "", and "" + gordon + "" years old"";\n\n- Formatting\nString s2 = String.format(\n""My nephews are %d, %d, %d, and %d years old"",\ndavid, dawson, dillon, gordon);\n\ns1 = s2 = ""My nephews are 13, 11, 4, and 2 years old""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Constructing String with Format Specifiers","1:10","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=4&mode=live&start=70.372738&noteid=2386ad4c-79ae-48e7-a69a-072f4b8f61f7"
"Concatenation vs. Formatting Example 2:\n\nint david = 13, dawson = 11, dillon = 4, gordon = 2;\ndouble avgDiff = ((david - dawson) +\n(dawson - dillon) + (dillon - gordon)) / 3.0d;\n\n- Concatenation\nString s3 =\n""The average age between each is "" + avgDiff + "" years"";\n\ns3 = ""The average age between each is 3.6666666666666665 years""\n\n- Formatting\nString s4 = String.format(\n""The average age between each is %.1f years"", avgDiff);\n\ns4 = ""The average age between each is 3.7 years""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Constructing String with Format Specifiers","3:56","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=4&mode=live&start=236.757868&noteid=8e4cb34f-1d4b-4424-9b5a-46650cb5d88d"
"Parts of a Format Specifier:\n%[argument index][flags][width][precision]conversion\n\n- % - must start with this\n- argument index - identifies how we want to associate format specifiers with the individual values\n- flags - allow us to specify further rules\n- width - identifies the minimum characters to display (space-padded, right-justified by default)\n- precision - identifies the number of decimal places we want to ddisplay\n- conversion - type of conversion you want to apply (integer, character, etc)\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Constructing String with Format Specifiers","5:38","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=4&mode=live&start=338.740203&noteid=dc6926de-09b5-4b26-98dd-beb23c5790fc"
"Common Format Conversions:\n\n- %d\n  - Meaning: decimal\n  - Type: Integral (int, Integer, short)\n  - Example value: 32\n  - Result: 32\n- %o\n  - Meaning: octal\n  - Type: Integral (int, Integer, short)\n  - Example value: 32\n  - Result: 40\n- %x / %X\n  - Meaning: hex\n  - Type: Integral (int, Integer, short)\n  - Example value: 32\n  - Result: 20\n- %f\n  - Meaning: decimal\n  - Type: floating point (float, double)\n  - Example value: 123.0\n  - Result: 123.000000\n- %e / %E\n  - Meaning: scientific notation\n  - Type: floating point (float, double)\n  - Example value: 123.0\n  - Result: 123.0000e+02\n- %c\n  - Meaning: character\n- %s\n  - Meaning: string\n  - Type: general\n  - Example value: ""Hello""\n  - Result: Hello\n  - Note: you can also pass into this format conversion object instances that are not strings.\n    - if the class for the object instance you passed in implements the Formattable interface, the formattable.Format method will be called, and whatever value that returns will appear in the resulting string.\n    - If the class for the object instance you passed in does NOT implement the Formattable interface, the toString() method will be called on the object instance, and whatever value that returns will appear in the resulting string.\n\nNote: check the Java site for all the possible format conversions, such as date/time/etc\n\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Common Format Conversions","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=5&mode=live&start=2.431655&noteid=69056b32-5e12-4e2f-9b4b-d9144e03a3f7"
"Format Flags:\n- allow us to enable specific formatting behaviors","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Format Flags","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=6&mode=live&start=0.704568&noteid=585b1f0d-b181-4490-bb7a-d064d80a12c1"
"\n- #\n - Meaning: include radix (we want to display something that indicates the base of the number being displayed)\n - Example:\nWithout Format Flag #: \n\nString s1 = String.format(“%d”, 32);     \n//s1 = 32\n\nString s2 = String.format(“%o”, 32); \n//s2 = 40\n\nString s3 = String.format(“%x”, 32); \n//s3 = 20\n\nWith Format Flag #:\n\nString s4 = String.format(“%#o”, 32); \n//s4 = 040\n\nString s5 = String.format(“%#x”, 32); \n//s5 = 0x20\n\nString s6 = String.format(“%#X”, 32); \n//s6 = 0X20","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Format Flags","3:33","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=6&mode=live&start=213.678354&noteid=c6da395c-10d3-496f-832c-e6681b5aee61"
"- 0\n - Meaning: zero-padding\n - Comes into effect when we specify the width of a value we'd like to display.\n- -\n - Meaning: Left justify\n - Comes into effect when we specify the width of a value we'd like to display.\n- Examples ( 0 and -):\n\nWithout Formatting:\n\ns1 = String.format(""W:%d X:%d"", 5, 235);\ns2 = String.format(""Y:%d Z:%d"", 481, 12);\n \nW:5 X:235\nY:481  Z:12\n\nWith Width of 4:\n\ns3 = String.format(""W:%4d X:%4d"", 5, 235);\ns4 = String.format(""Y:%4d Z:%4d"", 481, 12);\n \nW:   5 X: 235\nY: 481 Z:    12\n\nWith Width of 4 and Zero Padding:\n\ns5 = String.format(""W:%04d X:%04d"", 5, 235); \ns6 = String.format(""Y:%04d Z:%04d"", 481, 12); \n\nW:0005 X:0235\nY: 0481  Z:0012\n\nWith Width of 4 and Left Justification (values directly against the colon):\n\ns7 = String.format(""W:%-4d X:%-4d"", 5, 235); \ns8 = String.format(""Y:%-4d Z:%-4d"", 481, 12); \n\nW:5   X:235\nY:481 Z:12","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Format Flags","3:33","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=6&mode=live&start=213.678354&noteid=a5d22ac2-4d63-4e14-936d-78b7853ea07b"
"  - , (comma)\n    - Meaning: include grouping separator (for when we have numbers)\n    - Example:\n\ns1 = String.format(""%d"", 1234567); \n//s1 = 1234567\n\ns2 = String.format(""%,d"", 1234567); \n//s2 = 1,234,567\n\ns3 = String.format(“%,.2f"", 1234567.0); \n//s3 = 1,234,567.00","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Format Flags","3:37","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=6&mode=live&start=217.695176&noteid=bbd2be18-223a-4754-bad2-a9f3ca59d8a9"
"  - SPACE\n    - Meaning: when I write out a positive number, leave space for where the sign would be (+)\n  - +\n    - Meaning: always show the sign (positive: +, negative: -)\n  - (\n    - Meaning: enclose negative values in parentheses\n  - Examples:\n\nWithout format flags:\n\ns1 = String.format(""%d"", 123);\ns2 = String.format(""%d"", -456);\n\n123\n-456\n\nWith SPACE flag:\n\ns3 = String.format(""% d"", 123);\ns4 = String.format(""% d"", -456);\n\n  123\n-456\n\nWith + flag:\n\ns5 = String.format(""%+d"", 123);\ns6 = String.format(""%+d"", -456);\n\n+123\n-456\n\nWith ( flag:\n\ns7 = String.format(""%(d"", 123);\ns8 = String.format(""%(d"", -456);\ns9 = String.format(""% (d"", 123);\n\n123\n(456)\n  123","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Format Flags","4:24","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=6&mode=live&start=264.626737&noteid=ca8f3f50-3673-48ca-868f-74eae0359fde"
"Argument Index:\n- allows you to identify which argument value you want a particular format specifier to be associated with.\n\n- Types:\n\n- Not Specified\n  - Meaning: Corresponds sequentially to argument (first with first, second with second, etc)\n\n- $index_value\n  - Meaning: index of argument to use\n\n- <\n  - Meaning: corresponds to same argument as previous format specifier\n\n- Examples:\n\nNo argument Index:\n\ns1 = String.format(""%d %d %d"", 100, 200, 300);\n//s1 = ""100 200 300""\n\nUsing $index_value:\n\ns2 = String.format(""%$3d %$1d %$2d"", 100, 200, 300);\n//s2 = ""300 100 200""\n\n  - first specifier got 3rd argument, second specifier got 1st argument, and third specifier got 2nd argument\n\nUsing < :\n\ns3 = String.format(“%$2d %<04d %$1d"", 100, 200, 300);\n//s3 = ""200 0200 100""\n\n  - <  for second specifier meant that it used the same argument as the first specifier, so in this case, the first used 200, so the second also used 200\n  - < symbol is useful when you have a single value that you want to write out multiple times generally with different formats","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Argument Index","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=7&mode=live&start=1.802817&noteid=127c683a-335a-43ce-b18c-252f1b192202"
"Writing Formatted Content to a Stream:\n- Formatter class\n  - provides formatting capabilities\n  - writes content to any type that implements the Appendable interface\n(ex.StringBuilder, Writer)\n\n\n- Writer\n  - implements the Appendable interface\n  - therefore, we can use the Formatter class to write formatted content directly out to any class that it inherits from the writer class","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Writing Formatted Content to a Stream","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=8&mode=live&start=1.711961&noteid=6de2fc8a-8615-481f-b6b3-054aaad3af71"
"Writing Formatted Content to a Stream:\n\nvoid doWrite(int david, int dawson, int dillon,\nint gordon, double avgDiff) throws IOException {\n\nBufferedWriter writer =\nFiles.newBufferedWriter(Paths.get(""myFile.txt""));\n\ntry(Formatter f = new Formatter(writer)) {\n\nf.format(""My nephews are %d, %d, %d, and %d years old"",\ndavid, dawson, dillon, gordon);\n\nf.format(""The average age between each is %.1f years"",\navgDiff);\n\n}\n}\n\nNote: \n - BufferedWriter doesn't have to be in try-with-resources because the formatter automatically closes whatever it's wrapping as long as that class (in this case BufferedWriter) implements the Closeable interface\n\n- by creating a Formatter OVER the BufferedWriter, anything I write out to the Formatter class will go out to the BufferedWriter stream (both f.format statements get written out to the stream)\n\n- works with any writer stream","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Writing Formatted Content to a Stream","0:57","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=8&mode=live&start=57.895108&noteid=5e2e5899-485e-4317-9b4f-f4d97a931ee3"
"For More on Formatting:\n\n- Java Formatter documentation:\n  - Detailed format specifier information\n\n- Java 8 has date/time formatting:\n  - check Pluralsight ""What's New in Java 8""","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Writing Formatted Content to a Stream","2:53","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=8&mode=live&start=173.584807&noteid=5618d4a6-2e1c-409a-996a-152e87565727"
"String Matching with Regular Expressions:\n\n- Regular Expressions:\n  - a powerful pattern matching syntax\n  - provide a way for us to fid/exclude groups of characters\n  \n- Java support for regular expressions\n  - methods on the String class\n  - dedicated classes for working with regular expressions","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","String Matching with Regular Expressions","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=9&mode=live&start=0.506845&noteid=e86e3841-2a6d-4791-9fbe-18349c22da45"
"String Class Support for Regular Expressions:\n\n- replaceFirst,replaceAll methods\n  - returns a new updated string based on an existing string\n  - we give it a pattern, and that pattern identifies what parts of the string you want to change\n\n- split method\n  - splits a string into an array of strings\n  - we identify how we want to split the string up using a regular expression\n\n- match method\n  - identifies if a string matches a particular pattern","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","String Class Support for Regular Expressions","0:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=10&mode=live&start=5.43565&noteid=8af0ca3b-5aeb-45a4-bf29-221b31394ae3"
"Using the replaceAll method:\n\nString s1 = ""apple, apple and orange please"";\n\nString s2 = s1.replaceAll(""ple"", ""ricot"");\n//s2 = apricot, apricot and orange ricotase\n\nString s3 = s1.replaceAll(""ple\b"", ""ricot"");\n//s3 = apricot, apricot and orange please\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","String Class Support for Regular Expressions","0:47","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=10&mode=live&start=47.504556&noteid=2c77ca4b-5972-4c2e-8ffc-b4ec7dac09b9"
"Using the split and match methods:\n\nString s1 = ""apple, apple and orange please"";\n\nString[] parts = s1.split(""\b"");\n\nfor(String thePart:parts){\nif(thePart.matches(""\w+"")){\nSystem.out.println(thePart);\n}\n}\n\nPrintout:\napple\napple\nand\norange\nplease\n\nNote: \n- ""\b"" refers to the word break character, i.e. right after each word ends and right before each word (except the first if there's no space before it) begins\n- ""\w+"" refers to one or more occurrence of a word character","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","String Class Support for Regular Expressions","2:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=10&mode=live&start=122.483254&noteid=388ae3b4-6dcd-491b-96a4-2d9767977be7"
"Dedicated Regular Expression Classes:\n\nRegular expression considerations:\n- compilation is processing intensive\n- string methods repeat compilation on every use\n- It would be nice if we could leverage that compilation work that we've done once over and over again\n\nPattern class:\n- compiles a regular expression\n- creates an instance of a Matcher class based on that pattern\n\nMatcher class:\n- applies the compiled expression to a particular string","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Dedicated Regular Expression Classes","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=11&mode=live&start=1.486082&noteid=5d2b3bba-a53a-4567-914e-899dcdc010aa"
"Using Pattern and Matcher Classes:\n\nString value1 = ""apple, apple and orange please"";\nPattern pattern = Pattern.compile(""\w+"");\nMatcher matcher = pattern.matcher(value1);\nwhile(matcher.find())\nSystem.out.println(matcher.group());\n\nResult:\napple\napple\nand\norange\nplease","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Dedicated Regular Expression Classes","1:10","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=11&mode=live&start=70.973222&noteid=a79cca9b-8cbb-4cba-aa72-214d645441f7"
"Java provides the java.util.regex package for pattern matching with regular expressions. Java regular expressions are very similar to the Perl programming language and very easy to learn.\n\nA regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data.\n\nThe java.util.regex package primarily consists of the following three classes −\n\nPattern Class − A Pattern object is a compiled representation of a regular expression. The Pattern class provides no public constructors. To create a pattern, you must first invoke one of its public static compile() methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.\n\nMatcher Class − A Matcher object is the engine that interprets the pattern and performs match operations against an input string. Like the Pattern class, Matcher defines no public constructors. You obtain a Matcher object by invoking the matcher() method on a Pattern object.\n\nPatternSyntaxException − A PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.\n\nCapturing Groups\nCapturing groups are a way to treat multiple characters as a single unit. They are created by placing the characters to be grouped inside a set of parentheses. For example, the regular expression (dog) creates a single group containing the letters ""d"", ""o"", and ""g"".\n\nCapturing groups are numbered by counting their opening parentheses from the left to the right. In the expression ((A)(B(C))), for example, there are four such groups −\n\n((A)(B(C)))\n(A)\n(B(C))\n(C)\nTo find out how many groups are present in the expression, call the groupCount method on a matcher object. The groupCount method returns an int showing the number of capturing groups present in the matcher's pattern.\n\nThere is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by groupCount.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:08","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=8.725838&noteid=de86d02a-c62d-49f2-96cf-66d264934b99"
"Example\n\nFollowing example illustrates how to find a digit string from the given alphanumeric string −\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches {\n\n   public static void main( String args[] ) {\n      // String to be scanned to find the pattern.\n      String line = ""This order was placed for QT3000! OK?"";\n      String pattern = ""(.*)(\d+)(.*)"";\n\n      // Create a Pattern object\n      Pattern r = Pattern.compile(pattern);\n\n      // Now create matcher object.\n      Matcher m = r.matcher(line);\n      if (m.find( )) {\n         System.out.println(""Found value: "" + m.group(0) );\n         System.out.println(""Found value: "" + m.group(1) );\n         System.out.println(""Found value: "" + m.group(2) );\n      }else {\n         System.out.println(""NO MATCH"");\n      }\n   }\n}\nThis will produce the following result −\n\nOutput\n\nFound value: This order was placed for QT3000! OK?\nFound value: This order was placed for QT300\nFound value: 0","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:10","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=10.098547&noteid=460c42da-a406-402f-9867-324e5c2e27c9"
"Regular Expression Syntax\nHere is the table listing down all the regular expression metacharacter syntax available in Java −\n- ^ : Matches the beginning of the line.\n- $\tMatches the end of the line.\n-  .\tMatches any single character except newline. Using m option allows it to match the newline as well.\n- [...]\tMatches any single character in brackets.\n- [^...]\tMatches any single character not in brackets.\n- \A\tBeginning of the entire string.\n- \z\tEnd of the entire string.\n- \Z\tEnd of the entire string except allowable final line terminator.\n- re*\tMatches 0 or more occurrences of the preceding expression.\n- re+\tMatches 1 or more of the previous thing.\n- re?\tMatches 0 or 1 occurrence of the preceding expression.\n- re{ n}\tMatches exactly n number of occurrences of the preceding expression.\n- re{ n,}\tMatches n or more occurrences of the preceding expression.\n- re{ n, m}\tMatches at least n and at most m occurrences of the preceding expression.\n- a| b\tMatches either a or b.\n- (re)\tGroups regular expressions and remembers the matched text.\n- (?: re)\tGroups regular expressions without remembering the matched text.\n- (?> re)\tMatches the independent pattern without backtracking.\n- \w\tMatches the word characters.\nA word character: [a-zA-Z_0-9]\n- \W\tMatches the nonword characters.\n- \s\tMatches the whitespace. Equivalent to [\t\n\r\f].\n- \S\tMatches the nonwhitespace.\n- \d\tMatches the digits. Equivalent to [0-9].\n- \D\tMatches the nondigits.\n- \A\tMatches the beginning of the string.\n- \Z\tMatches the end of the string. If a newline exists, it matches just before newline.\n- \z\tMatches the end of the string.\n- \G\tMatches the point where the last match finished.\n- \n\tBack-reference to capture group number ""n"".\n- \b\tMatches the word boundaries when outside the brackets. Matches the backspace (0x08) when inside the brackets.\n- \B\tMatches the nonword boundaries.\n- \n, \t, etc.\tMatches newlines, carriage returns, tabs, etc.\n- \Q\tEscape (quote) all characters up to \E.\n- \E\tEnds quoting begun with \Q.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:14","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=14.571083&noteid=697e9438-d9e5-4bb7-ad77-99488a2ebc0c"
"Methods of the Matcher Class\nHere is a list of useful instance methods −\n\nIndex Methods\nIndex methods provide useful index values that show precisely where the match was found in the input string −\n\n1\t\npublic int start()\n\nReturns the start index of the previous match.\n\n2\t\npublic int start(int group)\n\nReturns the start index of the subsequence captured by the given group during the previous match operation.\n\n3\t\npublic int end()\n\nReturns the offset after the last character matched.\n\n4\t\npublic int end(int group)\n\nReturns the offset after the last character of the subsequence captured by the given group during the previous match operation.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=e931aa57-5bdc-4b97-b88f-b5e2c947e43d"
"Study Methods\n\nStudy methods review the input string and return a Boolean indicating whether or not the pattern is found −\n\n1\t\npublic boolean lookingAt()\n\nAttempts to match the input sequence, starting at the beginning of the region, against the pattern.\n\n2\t\npublic boolean find()\n\nAttempts to find the next subsequence of the input sequence that matches the pattern.\n\n3\t\npublic boolean find(int start)\n\nResets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index.\n\n4\t\npublic boolean matches()\n\nAttempts to match the entire region against the pattern.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=93b5b001-ce61-40a4-a2c3-f3217679f6ce"
"Replacement Methods\n\nReplacement methods are useful methods for replacing text in an input string −\n\n1\t\npublic Matcher appendReplacement(StringBuffer sb, String replacement)\n\nImplements a non-terminal append-and-replace step.\n\n2\t\npublic StringBuffer appendTail(StringBuffer sb)\n\nImplements a terminal append-and-replace step.\n\n3\t\npublic String replaceAll(String replacement)\n\nReplaces every subsequence of the input sequence that matches the pattern with the given replacement string.\n\n4\t\npublic String replaceFirst(String replacement)\n\nReplaces the first subsequence of the input sequence that matches the pattern with the given replacement string.\n\n5\t\npublic static String quoteReplacement(String s)\n\nReturns a literal replacement String for the specified String. This method produces a String that will work as a literal replacement s in the appendReplacement method of the Matcher class.\n","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=119b1f71-adca-4c04-a9da-eef03182573b"
"The start and end Methods\n\nFollowing is the example that counts the number of times the word ""cat"" appears in the input string −\n\nExample\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches {\n\n   private static final String REGEX = ""\bcat\b"";\n   private static final String INPUT = ""cat cat cat cattie cat"";\n\n   public static void main( String args[] ) {\n      Pattern p = Pattern.compile(REGEX);\n      Matcher m = p.matcher(INPUT);   // get a matcher object\n      int count = 0;\n\n      while(m.find()) {\n         count++;\n         System.out.println(""Match number ""+count);\n         System.out.println(""start(): ""+m.start());\n         System.out.println(""end(): ""+m.end());\n      }\n   }\n}\nThis will produce the following result −\n\nOutput\n\nMatch number 1\nstart(): 0\nend(): 3\nMatch number 2\nstart(): 4\nend(): 7\nMatch number 3\nstart(): 8\nend(): 11\nMatch number 4\nstart(): 19\nend(): 22\n\nYou can see that this example uses word boundaries to ensure that the letters ""c"" ""a"" ""t"" are not merely a substring in a longer word. It also gives some useful information about where in the input string the match has occurred.\n\nThe start method returns the start index of the subsequence captured by the given group during the previous match operation, and the end returns the index of the last character matched, plus one.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=2728db99-6508-472c-816a-254b443fa57a"
"The matches and lookingAt Methods\n\nThe matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference, however, is that matches requires the entire input sequence to be matched, while lookingAt does not.\n\nBoth methods always start at the beginning of the input string. Here is the example explaining the functionality −\n\nExample\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches {\n\n   private static final String REGEX = ""foo"";\n   private static final String INPUT = ""fooooooooooooooooo"";\n   private static Pattern pattern;\n   private static Matcher matcher;\n\n   public static void main( String args[] ) {\n      pattern = Pattern.compile(REGEX);\n      matcher = pattern.matcher(INPUT);\n\n      System.out.println(""Current REGEX is: ""+REGEX);\n      System.out.println(""Current INPUT is: ""+INPUT);\n\n      System.out.println(""lookingAt(): ""+matcher.lookingAt());\n      System.out.println(""matches(): ""+matcher.matches());\n   }\n}\nThis will produce the following result −\n\nOutput\n\nCurrent REGEX is: foo\nCurrent INPUT is: fooooooooooooooooo\nlookingAt(): true\nmatches(): false","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=d50a8710-5dc4-41c4-b823-11acdcf0ea10"
"\nThe replaceFirst and replaceAll Methods\n\nThe replaceFirst and replaceAll methods replace the text that matches a given regular expression. As their names indicate, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences.\n\nHere is the example explaining the functionality −\n\nExample\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches {\n\n   private static String REGEX = ""dog"";\n   private static String INPUT = ""The dog says meow. "" + ""All dogs say meow."";\n   private static String REPLACE = ""cat"";\n\n   public static void main(String[] args) {\n      Pattern p = Pattern.compile(REGEX);\n      \n      // get a matcher object\n      Matcher m = p.matcher(INPUT); \n      INPUT = m.replaceAll(REPLACE);\n      System.out.println(INPUT);\n   }\n}\nThis will produce the following result −\n\nOutput\n\nThe cat says meow. All cats say meow.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=af3851c2-7973-4471-b272-94eceb63750d"
"The appendReplacement and appendTail Methods\n\nThe Matcher class also provides appendReplacement and appendTail methods for text replacement.\n\nHere is the example explaining the functionality −\n\nExample\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches {\n\n   private static String REGEX = ""a*b"";\n   private static String INPUT = ""aabfooaabfooabfoob"";\n   private static String REPLACE = ""-"";\n   public static void main(String[] args) {\n\n      Pattern p = Pattern.compile(REGEX);\n      \n      // get a matcher object\n      Matcher m = p.matcher(INPUT);\n      StringBuffer sb = new StringBuffer();\n      while(m.find()) {\n         m.appendReplacement(sb, REPLACE);\n      }\n      m.appendTail(sb);\n      System.out.println(sb.toString());\n   }\n}\nThis will produce the following result −\n\nOutput\n\n-foo-foo-foo-","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=ddbc7190-6bf1-449c-874a-f48babf9bc8b"
"PatternSyntaxException Class Methods\n\nA PatternSyntaxException is an unchecked exception that indicates a syntax error in a regular expression pattern. The PatternSyntaxException class provides the following methods to help you determine what went wrong −\n\n1\t\npublic String getDescription()\n\nRetrieves the description of the error.\n\n2\t\npublic int getIndex()\n\nRetrieves the error index.\n\n3\t\npublic String getPattern()\n\nRetrieves the erroneous regular expression pattern.\n\n4\t\npublic String getMessage()\n\nReturns a multi-line string containing the description of the syntax error and its index, the erroneous regular expression pattern, and a visual indication of the error index within the pattern.","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","0:15","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=15.10965&noteid=5b0c4ba4-963b-499f-b8ba-a69ee48ca20c"
"Notes:\n- I copied and pasted the tutorialspoint page on regex in Java into the notes for future reference; everything after the headline ""Using Pattern and Matcher Classes"" until this point is part of the tutorialspoint page.\n- See https://stackoverflow.com/questions/16517689/confused-about-matcher-group-in-java-regex \nfor good explanation of Pattern/Matcher/Grouping, which I tried to summarize below\n- My conclusion:\n  - m.group() = m.group(0) = prints out the next instance of the string that satisfies the ENTIRE original pattern\n  - m.group(A) for some integer A:\n    - prints out the next instance of the string that satisfies group A of the original pattern.\n    - Example:\n       - Let the pattern pattern have a matcher m and let m be ""(.*)(\d+)"":\n   - Group 0 refers to the whole pattern, so m.group(0) = m.group() will provide the next instance of the string that satisfies the entire pattern ""(.*)(\d+)""\n   - Group 1 refers to the first parentheses, so m.group(1) will provide only the ""(.*)"" part from the next instance of the string that satisfies the pattern ""(.*)(\d+)""\n   - Group 2 refers to the second parentheses, so m.group(2) will provide only the ""(\d+)"" part from the next instance of the string that satisfies the pattern ""(.*)(\d+)""\n\n- My next conclusion:\n  - Let the pattern pattern have a matcher m\n  - m.lookingAt() returns true if it can match the input with the pattern just from the beginning of the region\n  - m.matches() returns true if the entire region satisfies the pattern\n  - Example:\nInput  = ""apple85k20a""\nPattern = ""(\w+)(\d)""\nLet the matcher be m\nm.lookingAt() -> true because starting from the left, ""(\w+)(\d)"" can be satisfied by apple85k20 (and ignore the 'a' or other future letters that follow)\nm.matches() -> false because ""(\w+)(\d)"" is NOT satisfied by the entirety of apple85k20a ( 'a' at the end ruins it)","Java Fundamentals: The Core Platform","String Formatting and Regular Expressions","Summary","2:14","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m3&clip=12&mode=live&start=134.186426&noteid=49254dab-729a-49f0-ac79-8a3497a3a6a2"
"Managing Groups of Data:\n- apps often need to manage data in commonly typed groups\n  - most basic solution is to use arrays\n- Arrays have limitations\n  - statically sized\n  - require explicit position management\n  - little more than a bunch of values\n- Collections provide more powerful options\n","Java Fundamentals: The Core Platform","Working with Collections","A First Look at Collections","0:07","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=1&mode=live&start=7.355494&noteid=5da960e5-2acd-43cf-8721-acc11960e09d"
"The Role of Collections:\n- Collections hold and organize values\n  - iterable\n  - can provide type safety\n  - tend to dynamically size\n- A wide variety of collections are available\n  - may simply be a list of values\n  - can provide optimization or sophistication\n    - ordering\n    - prevent duplicates\n    - manage data as name/value pairs\n    ","Java Fundamentals: The Core Platform","Working with Collections","A First Look at Collections","1:26","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=1&mode=live&start=86.29575&noteid=4441a781-9ed4-4a34-93e7-d4e78624033d"
"A Simple Collection of Objects:\n\nArrayList list = new ArrayList();\nlist.add(""Foo"");\nlist.add(""Bar"");\nSystem.out.println(“Elements: ” + list.size());\nfor(Object o:list)\nSystem.out.println(o.toString());\nString s = (String)list.get(0);\nSomeClassIMadeUp c = new SomeClassIMadeUp();\nlist.add(c);","Java Fundamentals: The Core Platform","Working with Collections","A First Look at Collections","2:45","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=1&mode=live&start=165.843992&noteid=ac4ff540-747a-444e-bbcc-f004e9fef3cc"
"Collections and Type Safety:\n- by default collections hold Object types\n  - must convert return values to desired type  \n  - doesn't restrict what types of values added\n\n- Collections can be type restricted\n  - uses the Java concept of generics\n  - type specified during collection creation\n\n- Collection type restriction is pervasive\n  -  return values appropriately typed\n  -  adding values limited to appropriate type\n","Java Fundamentals: The Core Platform","Working with Collections","Collections and Type Safety","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=2&mode=live&start=1.20136&noteid=9f6a985f-9b28-47a3-828c-da6797dd72e0"
"A Strongly Typed Collection:\n\nArrayList<String> list = new ArrayList< >();\nlist.add(“Foo”);\nlist.add(“Bar”);\nSystem.out.println(“Elements: ” + list.size());\nfor( String o:list)\nSystem.out.println(o );\nString s = list.get(0);\n\nSomeClassIMadeUp c = new SomeClassIMadeUp();\nlist.add(c); --> ILLEGAL because ArrayList only accepts Strings","Java Fundamentals: The Core Platform","Working with Collections","Collections and Type Safety","1:33","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=2&mode=live&start=93.530988&noteid=a744bfd4-7987-4c7c-a802-9218568a5855"
"Collection Interface:\n- each collection type has its own features\n  - but there are many that are common\n\n- Collection interface\n  - provides common collection methods\n  - implemented by most collection types\n    - Map collections are a notable exception\n  - extends the Iterable interface\n","Java Fundamentals: The Core Platform","Working with Collections","Collection Interface","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=3&mode=live&start=2.152153&noteid=ee47300d-475b-4dec-8818-d34254ca803c"
"Common Collection Methods:\n- size: returns numbr of elements\n- clear: removes all elements\n- isEmpty: returns true if no elements\n- add: add a single element\n- addAll: add all members of another collection","Java Fundamentals: The Core Platform","Working with Collections","Collection Interface","0:38","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=3&mode=live&start=38.992174&noteid=de6bd319-520d-4a5c-8eb4-14d89d32cc66"
"Adding Members from Another Collection:\n\nArrayList<String> list1 = new ArrayList<>();\nlist1.add(“Foo”);\nlist1.add(“Bar”);\nLinkedList<String> list2 = new LinkedList<>();\nlist2.add(“Baz”);\nlist2.add(“Boo”);\nlist1.addAll(list2);\nfor(String s:list1)\nSystem.out.println(s);\n\nNote:\nthe list1.addAll(list2) call does NOT affect list2 at ALL","Java Fundamentals: The Core Platform","Working with Collections","Collection Interface","1:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=3&mode=live&start=65.771209&noteid=2a8ff550-2130-48a9-bdd1-1717e07f0b82"
"Common Equality-based Methods:\n- contains: return true if contains element\n- containsAll: return true if contains all members of another collection\n- remove: remove element\n- removeAll: remove all elements contained in another collection\n- retainAll: remove all elements not contained in another collection\n\nNote: tests all use the Class' equals() method","Java Fundamentals: The Core Platform","Working with Collections","Collection Interface","1:42","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=3&mode=live&start=102.609348&noteid=aa16f327-81f7-42c0-903a-86a12753473c"
"Removing a Member:\n\npublic class MyClass {\nString label, value; // getters elided for clarity\npublic MyClass(String label, String value) {\n// assign label & value to member fields\n}\npublic boolean equals(Object o) {\nMyClass other = (MyClass) o;\nreturn value.equalsIgnoreCase(other.value);\n}\n}\n\nArrayList<MyClass> list = new ArrayList<>();\nMyClass v1 = new MyClass(""v1"", ""abc"");\nMyClass v2 = new MyClass(""v2"", ""abc"");\nMyClass v3 = new MyClass(""v3"", ""abc"");\nlist.add(v1);\nlist.add(v2);\nlist.add(v3);\n\nlist.remove(v3); //uses equals() method to find a match\n\nfor(MyClass m:list)\nSystem.out.println(m.getLabel());","Java Fundamentals: The Core Platform","Working with Collections","Collection Interface","2:25","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=3&mode=live&start=145.737359&noteid=8d62b55d-7a32-461a-a218-dce2ad09eb58"
"Java 8 Collection Methods:\n\n- Java 8 introduced lambda expressions\n  - simplify passing code as arguments\n\n- Collections have the ability to leverage lambda expressions to run code across its members.\n\n- Collection methods that leverage lambdas:\n  - forEach\n    - allows us to simply pass in a block of code and have that code just be run for each member in the collection \n  - removeIf\n    - we can pass in a lamda expression called a predicate (which evaluates to either true or false) , and then for every member for which that code resolves to true, that member is removed.\n","Java Fundamentals: The Core Platform","Working with Collections","Java 8 Collection Features","0:01","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=4&mode=live&start=1.430472&noteid=a1702a31-a841-4378-8b2a-6dad01a27e41"
"Using forEach method:\n\nArrayList<MyClass> list = new ArrayList<>();\nMyClass v1 = new MyClass(""v1"", ""abc"");\nMyClass v2 = new MyClass(""v2"", “xyz"");\nMyClass v3 = new MyClass(""v3"", ""abc"");\n\nlist.add(v1);\nlist.add(v2);\nlist.add(v3);\n\nlist.forEach(m -> System.out.println(m.getLabel()));\n\nResult:\nv1\nV2\nV3","Java Fundamentals: The Core Platform","Working with Collections","Java 8 Collection Features","1:13","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=4&mode=live&start=73.823841&noteid=1114b3e4-429c-4bca-adc6-c9f865daddd3"
"Using removeIf Method:\n\nArrayList<MyClass> list = new ArrayList<>();\nMyClass v1 = new MyClass(""v1"", ""abc"");\nMyClass v2 = new MyClass(""v2"", “xyz"");\nMyClass v3 = new MyClass(""v3"", ""abc"");\n\nlist.add(v1);\nlist.add(v2);\nlist.add(v3);\n\nlist.removeIf(m -> m.getValue().equals(“abc”));\n\nlist.forEach(m -> System.out.println(m.getLabel()));\n\nResult:\nv2","Java Fundamentals: The Core Platform","Working with Collections","Java 8 Collection Features","2:35","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=4&mode=live&start=155.072075&noteid=43370612-a614-4518-ba66-9beb745e9427"
"Lambda expressions make it really easy for us to run blocks of code across members of our collections.","Java Fundamentals: The Core Platform","Working with Collections","Java 8 Collection Features","3:40","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=4&mode=live&start=220.020142&noteid=a077ee47-eaf0-4418-b5e4-5a05819dfef4"
"Converting Between Collections and Arrays:\n\n- Sometimes APIs require an array:\n  - often due to legacy or library code\n\n- Collection interface can return an array\n  - toArray() method\n    - returns Object array\n  - toArray(T[] array) method\n    - returns array of T\n\n- Array content can be retrieved as a Collection:\n  - use Arrays class' asList() method","Java Fundamentals: The Core Platform","Working with Collections","Converting Between Collections and Arrays","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=5&mode=live&start=2.428702&noteid=2001c759-a8a9-46ee-8876-38c9698fa4cf"
"Retrieving a Collection from an Array:\n\nMyClass[] myArray= {\nnew MyClass(""val1"", ""abc""),\nnew MyClass(""val2"", “xyz""),\nnew MyClass(""val3"", “abc"")\n};\n\nCollection<MyClass> list = \n\nArrays.asList(myArray);\n\nlist.forEach(c -> System.out.println(c.getLabel()));","Java Fundamentals: The Core Platform","Working with Collections","Converting Between Collections and Arrays","2:37","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=5&mode=live&start=157.818846&noteid=05eee3e7-3910-47b0-a369-45de0f0df633"
"Collection Types:\n\n- Java provides a wide variety of collections\n  - each with specific behaviors\n\n- Collection interfaces\n  - provide contract for collection behavior\n\n- Collection classes\n  - provide collection implementation\n  -  implement 1 or more collection interfaces\n","Java Fundamentals: The Core Platform","Working with Collections","Collection Types","0:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=6&mode=live&start=0.827224&noteid=5b5de2fe-3c28-4794-aad8-ccdc846a4e1c"
"Common Collection Interfaces:\n\n- Collection: basic collection operations\n- List: Collection that maintains a particular order\n- Queue: Collection with the concept of order and a specific ""head"" element\n- Set: Collection that contains no duplicate values\n- SortedSet: a Set whose members are sorted","Java Fundamentals: The Core Platform","Working with Collections","Collection Types","0:36","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=6&mode=live&start=36.066337&noteid=c53981f6-1a73-4c76-ac8f-b3c1d5461587"
"Common Collection Classes:\n\n- ArrayList:\n  - a List backed by a resizable array\n  -  efficient random access but inefficient random inserts\n- LinkedList: \n  - a List and Queue backed by a doubly-linked list\n  - efficient random insert but inefficient random access\n- HashSet:\n  - a Set implemented as a hash table\n  - efficient general purpose usage at any time\n- TreeSet:\n  - a SortedSet implemented as a balanced binary tree\n  - Members accessible in order but less efficient to modify and search than a HashSet","Java Fundamentals: The Core Platform","Working with Collections","Collection Types","1:20","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=6&mode=live&start=80.882291&noteid=9b59521a-8ff8-4e00-a43a-1180930ec624"
"Sorting:\n- some collections rely on sorting\n  - There are 2 ways to specify sort behavior\n- 1) Comparable interface\n  - implemented by the type to be sorted\n  - type specifies its own sort behavior\n    - the behavior of the class' Comparable interface should be consistent with the implementation of class' equals() method. \n- 2) Comparator interface\n  - implemented by a type that performs a sort\n  - allows one type to specify the sort behavior for another type\n  - useful for cases where maybe you want a sorter type that doesn't implement the Comparable interface,  or you have situations where you want to provide an alternate sort than that provided by the Comparable interface","Java Fundamentals: The Core Platform","Working with Collections","Sorting","0:04","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=7&mode=live&start=4.360377&noteid=83365b8b-a895-4b9c-a14f-0516356fbc77"
"Implementing Comparable:\n\npublic class MyClass implements Comparable<MyClass> {\nString label, value; // Other members elided for clarity\n\npublic String toString() { return label + “ | ” + value;}\n\npublic boolean equals(Object o) {\nMyClass other = (MyClass) o;\nreturn value.equalsIgnoreCase(other.value);\n}\n\npublic int compareTo(MyClass other) {\nreturn value.compareToIgnoreCase(other.value);\n}\n}","Java Fundamentals: The Core Platform","Working with Collections","Sorting","1:08","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=7&mode=live&start=68.883883&noteid=92461dd1-9fc1-4de3-ad01-593a81937cb1"
"Using TreeSet with Comparable:\n\nTreeSet<MyClass> tree = new TreeSet<>();\ntree.add(new MyClass(""2222"", ""ghi""));\ntree.add(new MyClass(""3333"", ""abc""));\ntree.add(new MyClass(""1111"", ""def""));\ntree.forEach(m -> System.out.println(m));\n\nResult:\n\n3333| abc\n1111 | def\n2222 | ghi\n\nNotes:\n- the TreeSet maintains sorting, so they sort themselves as you add each one in, and so after adding each in, you can already print them all and they''ll be in order\n- TreeSet used the sort behavior provided by the comparable interface","Java Fundamentals: The Core Platform","Working with Collections","Sorting","2:13","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=7&mode=live&start=133.517203&noteid=8e9e4ff8-cf65-4af5-804d-d56bac5caf2a"
"Implementing Comparator:\n\npublic class MyComparator implements Comparator<MyClass> {\n\npublic int compare(MyClass x, MyClass y) {\nreturn x.getLabel().compareToIgnoreCase(y.getLabel());\n}\n}\n\nNote:\n- this class is responsible for providing sort behavior for another class (in this case it''ll be the MyClass class)","Java Fundamentals: The Core Platform","Working with Collections","Sorting","3:04","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=7&mode=live&start=184.579386&noteid=81e4688e-ecb5-4d5b-bada-5fab07a7ed49"
"Using TreeSet with Comparator:\n\nTreeSet<MyClass> tree = new TreeSet<>(new MyComparator());\n\ntree.add(new MyClass(""2222"", ""ghi""));\ntree.add(new MyClass(""3333"", ""abc""));\ntree.add(new MyClass(""1111"", ""def""));\n\ntree.forEach(m -> System.out.println(m));\n\nResult:\n1111 | def\n2222 | ghi\n3333| abc","Java Fundamentals: The Core Platform","Working with Collections","Sorting","3:52","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=7&mode=live&start=232.44674&noteid=b8ca0f64-5bf5-4ad4-bc35-ffe2589faba6"
"Map Collections:\n\n- Maps store key-value pairs\n  - key is used to identify/locate value\n  - keys are unique\n  - values can be duplicated\n  - values can be null","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","0:02","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=2.072464&noteid=9cd09cb4-daf2-4ccb-aa3e-55e72f396b1e"
"Common Map Types (Interfaces):\n\n- Map: basic map operations\n- SortedMap: map whose keys are sorted","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","0:34","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=34.344021&noteid=2213ead3-12dd-484f-876d-c861df193fda"
"Common Map Types (Classes):\n\n- HashMap: efficient general purpose Map implementation\n- TreeMap: \n  - SortedMap implemented as a self-balancing tree\n  - supports Comparable and Comparator sorting","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","0:54","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=54.197147&noteid=967b414b-0c2a-47e0-847d-646145b3466e"
"Common Map Methods:\n\n- put: add key and value\n- putIfAbsent: add key and value if key not contained or value is null\n- get: return value for key, if key not found return null\n- getOrDefault: return value for key, if key not found return the provided default value\n- values: return a Collection of the contained values\n- keySet: return a Set of teh contained keys \n- forEach: perform action for each entry (since Maps support lambdas)\n- replaceAll: perform action for each entry replacing each key's value with the action's result","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","1:22","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=82.856749&noteid=1d471453-7ab7-425d-bb84-e9639e2cfdbe"
"Using Map:\n\nMap<String, String> map = new HashMap<>();\n\nmap.put(“2222"", “ghi"");\nmap.put(“3333"", “abc"");\nmap.put(“1111"", “def"");\n\nString s1 = map.get(“3333”);\n//s1 = abc\n\nString s2 = map.get(“9999”);\n//s2 = null\n\nString s3 = map.getOrDefault(“9999”, “xyz”);\n//s3 = xyz","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","2:34","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=154.268523&noteid=ead5021d-48fa-4fcf-b91a-35f6de9d0b07"
"Using Map with Lambdas:\n\nMap<String, String> map = new HashMap<>();\n\nmap.put(“2222"", “ghi"");\nmap.put(“3333"", “abc"");\nmap.put(“1111"", “def"");\n\nmap.forEach( (k, v) -> System.out.println(k + “ | ” + v));\n\nResult:\n2222 | ghi\n3333 | abc\n1111 | def\n\nmap.replaceAll( (k, v) -> v.toUpperCase());\n\nmap.forEach( (k, v) -> System.out.println(k + “ | ” + v));\n\nResult:\n2222 | GHI\n3333 | ABC\n1111 | DEF\n\nNote:\n- the lambda expression in the forEach() method is called a BI-CONSUMER because it accepts 2 parameters.\n- the lambda expression in the replaceAll() method is a BI-FUNCTION in that it accepts two parameters, but also returns back a value\n  - in other words, in this case it calls toUpperCase on each value, takes the result of that, returns that back, and then the map apples that as the new value for that entry","Java Fundamentals: The Core Platform","Working with Collections","Map Collections","4:21","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=8&mode=live&start=261.792429&noteid=2b463491-355c-4066-a578-4da3c05c58f2"
"Common SortedMap Methods:\n\n- firstKey: returns first key in sort order\n- lastKey: returns last key in sort order\n- headMap: returns a map for all keys whose values are less than the specified key I passed in (excludes key I passed in)\n- tailMap: returns a map for all keys whose values are greater than or equal to than the specified key I passed in (includes key I passed in)\n- subMap: returns a map for all keys that are greater than or equal to the starting key I passed in and less than the ending key I passed in","Java Fundamentals: The Core Platform","Working with Collections","Sorted Map Collections","0:05","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=9&mode=live&start=5.713327&noteid=c48b2dd9-ea63-4007-b2b7-92ccc5303811"
"Using SortedMap:\n\nSortedMap<String, String> map = new TreeMap<>();\n\nmap.put(“2222"",“ghi"");\nmap.put(“3333"",“abc"");\nmap.put(“1111"",“def"");\nmap.put(“6666"",“xyz"");\nmap.put(“4444"",“mno"");\nmap.put(“5555"",“pqr"");\n\nmap.forEach( (k, v) -> System.out.println(k + “ | ” + v));\n\nResult:\n\n1111 | def\n2222 | ghi\n3333 | abc\n4444 | mno\n5555 | pqr\n6666 | xyz","Java Fundamentals: The Core Platform","Working with Collections","Sorted Map Collections","1:18","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=9&mode=live&start=78.125744&noteid=566f1516-8427-407c-951b-6d0433850540"
"Using SortedMap:\n\nSortedMap<String, String> map = new TreeMap<>();\n// Add same 6 key/value pairs as last slide\n\nSortedMap<String, String> hMap = map.headMap(“3333”);\n\nhMap.forEach( (k, v) ->\nSystem.out.println(k + “ | ” + v));\n\nResult:\n1111 | def\n2222 | ghi\n\nSortedMap<String, String> tMap = map.tailMap(“3333”);\n\ntMap.forEach( (k, v) ->\nSystem.out.println(k + “ | ” + v));\n\nResult:\n3333 | abc\n4444 | mno\n5555 | pqr\n6666 | xyz","Java Fundamentals: The Core Platform","Working with Collections","Sorted Map Collections","2:00","https://app.pluralsight.com/player?course=java-fundamentals-core-platform&author=jim-wilson&name=java-fundamentals-core-platform-m4&clip=9&mode=live&start=120.684211&noteid=0654f7d3-4de0-4856-a56d-b92e9ffdd176"