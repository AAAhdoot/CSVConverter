"Note","Course","Module","Clip","Time in Clip","URL"
"Generics stop runtime errors at compile time","Java Fundamentals: Generics","The What and Why of Java Generics","Introduction","3:01","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m1&clip=0&mode=live&start=181.883486&noteid=08bfefd7-7ca4-4810-ad73-0986c1d43929"
"ClassName<T>","Java Fundamentals: Generics","The What and Why of Java Generics","Making our Circular Buffer Generic","0:31","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m1&clip=3&mode=live&start=31.401877&noteid=e61538ac-9f13-480f-a196-bed7813bf236"
"A generic class allows you to standardize a class for any type, and once you decide what type it is in that instance, it won't accept any other type.\nExample: ArrayList<String> only accepts strings, ArrayList<Integer> only accepts ints\nGeneric class example:\npublic class GenericCircularBuffer<T>\n{\n    private final T[] buffer;\n    private int readCursor = 0;\n    private int writeCursor = 0;\n\n    @SuppressWarnings(""unchecked"")\npublic GenericCircularBuffer(int size)\n    {\n   buffer = (T[]) new Object[size];\n    }\n\npublic boolean offer(T value)    {\n    if (buffer[writeCursor] != null)\n     {\n            return false;\n        }\n\n        buffer[writeCursor] = value;\n        writeCursor = next(writeCursor);\n        return true;\n    }\n\n    @SuppressWarnings(""unchecked"")\n    public T poll()\n  {\n   T value = buffer[readCursor];\n    if (value != null)\n     {\n    buffer[readCursor] = null;\n    readCursor = next(readCursor);\n     }\n     return value;\n    }\n\n private int next(int index)\n    {\n  return (index + 1) % buffer.length;\n    }\n}\n\n- notice how all the places where the type would be (and the inside of the <>) have the letter T inside, to represent the ability to take in any type","Java Fundamentals: Generics","The What and Why of Java Generics","Making our Circular Buffer Generic","3:32","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m1&clip=3&mode=live&start=212.401654&noteid=5a6d22a1-dc59-4468-8275-cd06ba632f0b"
"- Generics help give us type safety, so like you can't input an integer into a place where only Strings are allowed, and etc\n\n- a generic interface is an interface that allows for any type to be used inside it","Java Fundamentals: Generics","The What and Why of Java Generics","Summary","0:37","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m1&clip=4&mode=live&start=37.64792&noteid=733886de-d2d4-496d-81c8-4992767500e0"
"List\n- an ordered collection\n\nNote:\nList<Person> madMen = new List <Person>() is actually illegal, because list an interface, and there are different ways to implement it (Array, ArrayList, LinkedList, etc)\n\nAll ""List"" means is that it's a collection with an order\n\nYou could also use an Iterator (generic as well) to loop over an ArrayList, but the following news is even better:\n\nYou can use for-each loops for ArrayLists as well!\n\nNote 2:\n- you don't have to fill in the type in the <> if you've already filled it in on the right, because the left can just infer the type from the right side.\nMeaning that\nList<Person> madMen = new ArrayList<>(); is totally LEGAL and the ArrayList will only accept the Person type\n\nExample:\npublic class ListExamples\n{\n    public static void main(String[] args)\n    {\n        Person donDraper = new Person(""Don Draper"", 89);\n        Person peggyOlson = new Person(""Peggy Olson"", 65);\n\n        List<Person> madMen = new ArrayList<Person>();\n        madMen.add(donDraper);\n        madMen.add(peggyOlson);\n\n        System.out.println(madMen);\n\n        // Lists auto-resize, with generic add method\n        madMen.add(new Person(""Bert Cooper"", 100));\n\n        // Compile Error:\n        // madMen.add(new Object());\n\n        System.out.println(madMen);\n\n        // We can query for size\n        System.out.println(madMen.size());\n\n        // Lists have order, we retrieve elements by index\n        for (int i = 0; i < madMen.size(); i++)\n        {\n            // Generic get method\n            Person person = madMen.get(i);\n            System.out.println(person);\n        }\n\n        // can loop over them with a for loop\n        for (Person character : madMen)\n        {\n            System.out.println(character);\n        }\n\n        // Can still add duplicates though\n        madMen.add(peggyOlson);\n    }\n}\n","Java Fundamentals: Generics","Java's Generic Collections and Friends","Introduction","0:28","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m2&clip=0&mode=live&start=28.76232&noteid=c4f38faf-3242-4caf-8390-27893a0d1ee7"
"Set\n- a collection with unique elements\n- if you add the same element twice to a set, when you print out all the elements, each element is only printed once, because sets ensure uniqueness of elements\n- Set<Person> madMen = new HashSet<>;\n- you can iterate over a set the same way you'd iterate over a list (for-each)\n- however, Sets DON'T have order, so if you do madMen.get(0), you''ll get a compile error\n   - furthermore, there's no defined ordering in a Set at all, so when you use the for-each loop to print each element, the order can be different each time\n- Sets have a contains(Object obj) method that returns true or false depending on if the object specified exists in that set (from the looks of the Java site, Lists have this also)\n- Sets also have other useful methods that Lists don't have","Java Fundamentals: Generics","Java's Generic Collections and Friends","Sets","0:10","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m2&clip=3&mode=live&start=10.913589&noteid=2dbcc22b-4797-4c9b-9c90-63e70f6f27cc"
"Map\n- a dictionary that maps a single value to each unique key\n- keys are unique, and for each key, there's a single value associated with it\n- Map <K,V>, where K= key type, and\nV = value type\n- ex. Map<String,Person> madMen = \nnew HashMap<>();\n-  put(K key, V value) inserts the value of type V under the key of type K\n - ex. madMen.put(donDraper.getName(), donDraper) inserts the value donDraper under the key donDraper,getName();\n- get(Object key) will return the value V associated with the key\n - ex. madMen.get(""Don Draper"") will return the value associated with the key ""Don Draper""\n- you can associate one value with multiple keys, but each key has to be UNIQUE\n- with a Map we have Keys and Values, so we actually have 3 different iteration combinations:\n  - Iterating over the Keys:\n    - for( String name: madMen.keySet())\n      - returns us a Set with all the keys\n  - Iterating over the Values:\n    - for( Person person: madMen.values())\n      - returns a Collection with all the values\n- Iterating over the Keys & Values (or essentially over each element in the Map):\n  - for(Map.Entry<String,Person> entry: madMen.entrySet())\n    - returns each complete element (each key-value pair), from which you can gain the individual components as well using:\n       - entry.getKey() and entry.getValue()\n- Note: you can have as many generic parameters on a class as you need to, although recommended not to go above 2 or 3","Java Fundamentals: Generics","Java's Generic Collections and Friends","Maps","0:08","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m2&clip=4&mode=live&start=8.869506&noteid=27e54e67-4e87-450b-b642-cf85c6ee9fd4"
"List<T> -> ArrayList<T>\n     |      \nLinkedList<T>\n\nList<T> interface could be implemented using ArrayList<T>, LinkedList<T>, etc\n\n","Java Fundamentals: Generics","Generic Classes and Interfaces","Introduction","0:29","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=0&mode=live&start=29.183887&noteid=9c0cef3c-28c9-4e64-a2a6-e5c3d06acafe"
"How do generics interact with inheritance?","Java Fundamentals: Generics","Generic Classes and Interfaces","Introduction","1:26","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=0&mode=live&start=86.974571&noteid=da7a6c03-4695-4b8a-8718-b79cb526ac45"
"Implementing a generic type:\n- Java has a class called Collections in the java.util package, and this class has a method called Collections.sort:\n\n- sort(List<T> list, Comparator<? super T> c)\nSorts the specified list according to the order induced by the specified comparator.\n\n- so to sort by age, we create an AgeComparator by doing:\n  - import java.util.Comparator;\n\npublic class AgeComparator implements Comparator<Person>\n{\n    public int compare(final Person left, final Person right)\n    {\n        return Integer.compare(left.getAge(), right.getAge());\n    }\n}\n  - so therefore to sort in the main class we can do:\n    - Collections.sort(madMen,new AgeComparator());","Java Fundamentals: Generics","Generic Classes and Interfaces","Implementing a Generic Type","1:28","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=1&mode=live&start=88.414646&noteid=da64e947-9352-4dae-9d6d-fa70433f7151"
"You can either multiply the Comparator's result by -1, or create a ReverseComparator that takes in an original Comparator as an argument and inside the ReverseComparator class multiplies by -1 when comparing","Java Fundamentals: Generics","Generic Classes and Interfaces","Passing a Parameter to a Generic Type","6:27","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=2&mode=live&start=387.877358&noteid=01a62fb0-3ca1-4ebb-8eef-a13532f6415a"
"Type Bounds:\n- instead of allowing our generic type T to be anything, we want to put some constraints on that T\n- As you can see in the bottom example, \n<T extends Comparable<T>> will make the compiler know that anything passed into the ""left"" or ""right"" parameters is a class that implements the Comparable interface\n  - and therefore you can write\nif(left.compareTo(right)<0) with the knowledge that for whatever type is passed in, this will work\n- Example:\npublic class SortedPair<T extends Comparable<T>>\n{\n    private final T first;\n    private final T second;\n\n    public SortedPair(T left, T right)\n    {\n        if (left.compareTo(right) < 0)\n        {\n            first = left;\n            second = right;\n        }\n        else\n        {\n            first = right;\n            second = left;\n        }\n    }\n\n    public T getSecond()\n    {\n        return second;\n    }\n\n    public T getFirst()\n    {\n        return first;\n    }\n}\n- the reason you have \n<T extends Comparable<T>>\nis to say that we've got a generic parameter called T, both the values in our slots are gonna be a T, and they're going to implement the Comparable interface, and they're gonna be comparable to themselves","Java Fundamentals: Generics","Generic Classes and Interfaces","Type Bounds","0:00","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=3&mode=live&start=0.538394&noteid=c289b4f8-75d4-498d-86bc-65e021a39d81"
"Our 3 Recipes:\n- Implementing a generic type:\n  - AgeComparator implements Comparator<Person>\n- Passing a parameter to a generic type:\n  - Reverser<T> implements Comparator<T>\n- Type Bounds:\n  - SortedPair<T extends Comparator<T>>","Java Fundamentals: Generics","Generic Classes and Interfaces","Conclusion","0:38","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=4&mode=live&start=38.055549&noteid=c42d3fbe-1940-4b70-adc1-899ca1c4536d"
"Generics on Methods\n- It is possible to have generics on methods\n- Syntax:\npublic static <T> return_type function_name(parameter_list)\n  - note that the public static is not necessary, it's just important to note that the <T> must be after the quantifiers and before the return type\n- we can then also declare the parameters to be of type T, as follows:\n public static <T> T min(List<T> values, Comparator<T> comparator)\n  - we can add the <T> to the parameters because they are in the scope of the type <T> from the method signature\n  - note that the scope of <T> is only limited to this one method\n- Full example:\npublic static <T> T min(List<T> values, Comparator<T> comparator)\n    {\n        if (values.isEmpty())\n        {\n            throw new IllegalArgumentException(""Unable to find the minimum of an empty list"");\n        }\n\n        T lowestFound = values.get(0);\n\n        for (int i = 1; i < values.size(); i++)\n        {\n            final T element = values.get(i);\n            if (comparator.compare(element, lowestFound) < 0)\n            {\n                lowestFound = element;\n            }\n        }\n\n        return lowestFound;\n    }","Java Fundamentals: Generics","Generic Classes and Interfaces","Conclusion","2:25","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m3&clip=4&mode=live&start=145.306&noteid=354848db-9e57-4356-a250-2c7917c0fa3a"
"Note:\n- <T> before the return type means that generics can be used within the scope of that one method\n- T as the return type itself means that you can literally return the generic type T when you're done with the function","Java Fundamentals: Generics","Generics on Methods","Summary","0:54","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m4&clip=3&mode=live&start=54.787684&noteid=abcc6245-2282-4bbe-a29c-868702ff0a09"
"Also just a sidenote, the Collections class actually has its own ""min"" method that we can use","Java Fundamentals: Generics","Generics on Methods","Summary","1:39","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m4&clip=3&mode=live&start=99.699&noteid=222f6401-9dbe-40a9-a8aa-5775c9de3992"
"Wildcards:\n- if you ever see a generic type parameter, and then you see a ""?"", that's a wildcard\n- Upper Bounded: List<? extends Class>\n- Lower Bounded: List<? super Class>\n- Unbounded: List<?>/Class<?>","Java Fundamentals: Generics","Wildcards","Introduction","1:13","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=0&mode=live&start=73.883988&noteid=a3c2bc60-4c2f-4dcd-8a8f-a1dbf90b4f5f"
"The Substitution Principle:\n - whenever we pass in an argument/parameter to a method, we can pass in a subclass or maybe it was typed as an interface, and we can pass in someting that implements that interface. \n- Example: instead of having to pass in a Person, we can pass in a Partner or an Employee, both of which extend the Person class\n- it's all about what we call subtyping\n-  Arrays are covariant, which makes them unsafe, while Lists are not covariant, which makes them safe\n- It also works for arrays, but be careful with typesafe issues, because while Partners and Employees are Persons (meaning that you can take a class and assign it to its parent), Partner!=Employee, so if you try to store an Employee in a Partner array (or vice versa) you''ll get an error at runtime\n- Regarding Lists, it is totally typesafe, but arguably too typesafe at some points because you''ll get a compiler error if you try to pass in a subclass as a parameter instead of the parent, unless you use the appropriate wildcard/bounded things, which we''ll talk about next:","Java Fundamentals: Generics","Wildcards","The Substitution Principle","0:06","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=1&mode=live&start=6.288338&noteid=31fa9cd1-b7cb-421f-90cd-f7d15a059d73"
"Upper Bounded Wildcards:\n- so our issue in the example was that we had a parameter that accept a List<Person>, but we want it to accept anything that is a subclass of Person as well, such as Employee or Partner\n- by changing it from List<Person> \n--> List<? extends Person> , that parameter will accept any class that extends the Person class, which is any subclass of Person\n- so in conclusion:\n  - List<className> only accepts the type className\n  - List<? extends className> accepts className or any subclass of className\n  - ""? extends"" adds the UPPER BOUND\n- however, another thing we could have done was make the return type <T extends Person> and then make the parameter List<T>, as follows:\n  - public <T extends Person> void saveAll(final List<T> persons)\n- Difference between <T extends Person> and <? extends Person>:\n  - Use <T extends Person> when you want to declare a class and you want to restrict it and refer to that type elsewhere in your code\n  - Use <? extends Person> for something like a parameter on a method, where you want to have that additional flexibility but you don't really need all those type parameters lying around, cluttering up your code","Java Fundamentals: Generics","Wildcards","Upper Bounded Wildcards","0:06","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=2&mode=live&start=6.243995&noteid=7ec51061-2b90-47c3-ae4c-507fef789d7c"
"Lower Bounded Wildcards:\n- so in conclusion:\n  - List<className> only accepts the type className\n  - List<? super className> accepts the className or anything that's a parent of className\n  - ""? super"" adds the LOWER BOUND\n- Note 1:\n  - it's only safe to use ""extends""  when you're just getting things out of the list\n  - it's only safe to use ""super"" when you're putting things into the list\n- Note 2""\n  -  covariant -> ? extends -> generic parameter that can be SUBCLASSED\n  - contravariants -> ? super -> generic parameter that can be a SUPERCLASS or an INTERFACE that you've implemented","Java Fundamentals: Generics","Wildcards","Lower Bounded Wildcards","0:02","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=3&mode=live&start=2.889382&noteid=1d49c513-858b-4ba1-894e-2b8ef23f270b"
"Unbounded Wildcards:\n- when you just see the ? on its own without any ""extends"" or ""super"" at all\n- ? is shorthand for ""? extends Object""\n- useful when you don't care what type parameter it is; the only thing you care is that it's there, it exists\n- Difference between List<?> and List<Object>:\n  - List<?> means it could be a list of any type, I just don't know which\n     - the only thing you could add to this list is null, because null is the only value that can be coerced into any type that we know of\n  - List<Object> would mean it was specifically a list containing the type that represented the class Java lang Object\n    - you could add anything to this list, because everything stems from the type Object","Java Fundamentals: Generics","Wildcards","Unbounded Wildcards","0:06","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=4&mode=live&start=6.494434&noteid=38cceca9-f7a8-4b0c-8400-15f9d75f516a"
"Conclusions:\n- ? extends:\n  - declare an upper bound for the type parameter\n  - used to get data out of the parameter\n  - covariance\n- ? super:\n  - declare a lower bound for the type parameter\n  - to put data into the parameter\n  - contravariance","Java Fundamentals: Generics","Wildcards","Conclusion","0:24","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=5&mode=live&start=24.76338&noteid=f09a20ce-4ed8-462c-a2c1-5540eaf5eb67"
"Guideline for Usage:\n- get data with ""? extends""\n- put data with ""? super""\n- use ""?"" instead of ""? extends Object""\n- if you have a type parameter in which you need to both get and put values into and out of, you shouldn't use wildcards at all","Java Fundamentals: Generics","Wildcards","Conclusion","2:04","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m5&clip=5&mode=live&start=124.089082&noteid=1c925ba5-4374-482e-ab92-c8fda853540c"
"- Java maintains a concept of migration compatibility: you can upgrade to a new Java version and your code doesn't ""break"".\n- Legacy code = a class file that was compiled BEFORE Java had generics\n- Binary Compatibility: you can replace a legacy class file with a generic class file without changing or recompiling any client code.\n  - Client code = code that makes use of that class","Java Fundamentals: Generics","Raw Types and Compatibility","The Compatibility Problem","0:02","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=0&mode=live&start=2.488879&noteid=9f1bca76-e4f1-4681-9138-a99885583453"
"Raw Types:\n- a type which exists purely to allow interoperability and compatibility with legacy libraries (ex. List list)\n- a raw type is just a usage of a generic type that doesn't have any generic parameters, and so it can still be compatible with our legacy code.\n- however, List list != List<Object> List\n  - List<String> strings = List<Object> list; will NOT COMPILE, however\nList<String> strings = List list; WILL COMPILE\n- raw types mean that we have an unsafe scenario in our code, and can introduce runtime errors\n- raw types provide compatibility, but at a cost","Java Fundamentals: Generics","Raw Types and Compatibility","The Compatibility Problem","4:30","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=0&mode=live&start=270.343669&noteid=e4f66a67-b00d-45bb-9062-c740101ba51e"
"Erasure:\n- how generics get implemented\n- The key point about erasure as a concept is that the generic representation is a fallacy: it only really exists in the source code of the Java program, and as we translate it to bytecode we erase or remove the generic types.\n  - translation at compile time, not runtime\n- Erasure involves 3 steps:\n  - Erase type parameters\n  - Add casts\n  - Add bridge methods","Java Fundamentals: Generics","Raw Types and Compatibility","Erasure","0:00","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=2&mode=live&start=0.185587&noteid=e8a255e4-cdbe-41c2-9099-74a38927ace8"
"Erasure:\n- once the generics hit runtime, they don't really exist anymore\n- List<String>, List<Integer>, List<List<Integer>> -> List\n- List<String>[] -> List[]\n- T without bounds -> Object\n- T extends Foo -> Foo","Java Fundamentals: Generics","Raw Types and Compatibility","Erasure","3:15","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=2&mode=live&start=195.461043&noteid=87ff5f21-e54d-413c-9bb9-712ba87f781f"
"Implications of Erasure - Downsides and Tradeoffs:\n- Overloading:\n  - means that you can have two methods with the same name,but different type signature\n  - however:\n    -  print(Integer param) and print(String param) and print(List<String> param) -> LEGAL\n    - print(List<String> param) and print(List<Integer> param) -> ILLEGAL, because ""both methods have the same erasure"", meaning that at runtime, both look like a List<Object> to the compiler\n  - the restriction is only on different type parameters which are differentiable only by their generic types\n- Checking the type of an Instance\n    - it's illegal to have a generic type parameter when we're using an ""instanceof"", because at runtime that class doesn't really exist\n    - you can't extend anything that's throwable (anything which you can do a ""throw new"" of with generics in\n      - essentially you can't catch generic exceptions\n- Performance:\n  - erasure stops us from having primitive elements in the array, forces us to use boxed values for numeric types (such as java.lang.Integer rather than the primitive int), and that has a big downside, both in terms of how flat our memory is, and thus how fast and predictable it is to get its prefetch into your CPU cache and also how much memory it takes up in raw terms.\n- Upside:\n  - because Java takes this approach of erasure, Java has great compatibility.","Java Fundamentals: Generics","Raw Types and Compatibility","The Implications of Erasure","0:00","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=3&mode=live&start=0.878987&noteid=76fc8980-dd53-4c3a-bc07-f6df3b5dc60a"
"Reifiable Types and Arrays:\n- arrays, which predate generics, are one of the few genuinely reified types in Java\n- you can implement an ArrayList using arrays under the hood\n- private T[] values = new T[0]; is ILLEGAL because at runtime we don't know what that T is; it get's erased.\n- Possible approaches:\n  - private T[] values = (T[]) new Object[0]; is LEGAL because arrays are covariant and so an Object array can be cast to any kind of T array.\n  - private Object[] values = new Object[0];\npublic T get(final int index){\nreturn (T)values[index]; }","Java Fundamentals: Generics","Raw Types and Compatibility","Reified Types and Arrays","0:02","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=4&mode=live&start=2.154229&noteid=ca23309d-9a7a-4069-97db-b49e6a50de63"
"Summary:\n- there's a bad and ugly side of generics as well as a good one\n- erasure has significant downsides and limitations\n- raw types achieve compatibility, but are error prone\n  - mainly useful if you're maintaining legacy code","Java Fundamentals: Generics","Raw Types and Compatibility","Summary","0:17","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m6&clip=5&mode=live&start=17.219761&noteid=9b26e261-bfb0-46ad-957f-352d9ed957db"
"Note on Reflection Module:\n- this is only reflection with regards to generics, and apparently there's a course about reflection as a whole, so outisde of class literals, I'm gonna watch these reflection videos after having learned about reflection in general.\n- Essentially, REWATCH EVERYTHING after having learned about reflection in general","Java Fundamentals: Generics","Reflection","Introduction","1:24","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m7&clip=0&mode=live&start=84.644829&noteid=f63084b2-541e-4a26-a7cc-95df695afcd0"
"Class Literals:\n- allows you to instantiate generic types in a typesafe manner\n- we want a way of saying: ""give me an instance of this specific type"", and the way to do that is by using class literals\n- you can use a class literal to ensure  that your other class returns you a value of a given type.\n  - public <T> T newInstance(final Class<T> type){ return null;}\n  - and then in the main:\n    - Logger logger = injector.newInstance(Logger.class)\n    - Now, the following code will cause a compile error:\n      - Logger logger = injector.newInstance(String.class)\n      - String logger = injector.newInstance(Logger.class)\n","Java Fundamentals: Generics","Reflection","Class Literals","7:36","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m7&clip=1&mode=live&start=456.684125&noteid=ef69b2e6-2e38-4399-b865-fdf4fca3da71"
"Note on Advanced Types:\n- watch intro to Java 8 and other vids related to Functional Interfaces, Type Inference, and Intersection Types, before watching these, because these videos are specific to generics.","Java Fundamentals: Generics","Advanced Topics","Introduction","2:04","https://app.pluralsight.com/player?course=java-generics&author=richard-warburton&name=java-generics-m8&clip=0&mode=live&start=124.339924&noteid=74109081-cc29-46c3-8013-bf18b00eadf4"