"Note","Course","Module","Clip","Time in Clip","URL"
"Java is both a programming language and a runtime environment\n\nImportant Note:\n- TO ACCESS THE FIRST ARGUMENT PROVIDED BY THE USER, YOU ACCESS ARGS[0]","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","What Is Java","0:23","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=3&mode=live&start=23.414679&noteid=23027b91-8804-495a-bd03-9bd3784d8d4d"
" Java SE, EE, ME, FX, Android all support Java","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","What Is Java","0:51","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=3&mode=live&start=51.735679&noteid=6e96ace1-b45a-43b7-a5b2-0c00ead546c6"
"  JRE - Java Runtime Environment\n  JDK - Java Developing Kit\n","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","What Is Java","1:25","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=3&mode=live&start=85.205378&noteid=78f411e4-31c8-4879-977d-c251657d10f3"
" JRE\n- required to run Java apps\n- End-users normally require only the JRE","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","JRE vs. JDK","0:18","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=4&mode=live&start=18.772765&noteid=4d000063-908e-4201-b064-12dd8d788121"
"JDK\n- provides tools required to create java apps\n- developers nomally require the JDK\n- JDK installation includes a JRE","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","JRE vs. JDK","0:37","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=4&mode=live&start=37.559423&noteid=52da4b85-70c3-4302-bbba-41ff6e276ff7"
"IDE - Integrated Development Environment","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","Integrated Development Environments (IDE)","0:11","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=6&mode=live&start=11.664434&noteid=8a2eb3c8-c55c-4e91-b635-c302d2a88e5a"
"IDEs allow you to type, compile, debug, and all in one place","Java Fundamentals: The Java Language","Introduction and Setting up Your Environment","Integrated Development Environments (IDE)","0:34","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m1&clip=6&mode=live&start=34.025777&noteid=8aae3277-dcf9-400c-ae8d-cad8d16cd94e"
"public static void main(String[] args)","Java Fundamentals: The Java Language","Creating a Simple App","Demo: Creating Your First IntelliJ Project","3:43","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=1&mode=live&start=223.223643&noteid=bc4bbdc7-c79c-4e0f-928b-5089af9df9b3"
"java Main\n\n- used to run Main.class file in terminal","Java Fundamentals: The Java Language","Creating a Simple App","Demo: Running from the Command Line","5:30","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=2&mode=live&start=330.492017&noteid=586c7f7d-b1d5-4f98-992d-ed382773ba23"
"javac Main.java\n\n- used to compile in terminal","Java Fundamentals: The Java Language","Creating a Simple App","Statement Structure and Whitespace","2:06","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=3&mode=live&start=126.294819&noteid=9baf3a47-2147-428a-bff0-2e051df4c8bc"
"Comments\n\n- //\n- /*     */\n- /**    */ (used for documentation, I used mainly the top two)","Java Fundamentals: The Java Language","Creating a Simple App","Comments","0:52","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=4&mode=live&start=52.320742&noteid=d03c9330-786c-476b-b861-4b61065ac55a"
"cannot nest block comments","Java Fundamentals: The Java Language","Creating a Simple App","Demo: Comments","3:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=5&mode=live&start=182.215895&noteid=d81a55c6-6379-412a-b3e4-0e39b1978288"
"packages provide organization\n- follow standard naming and affect source code file structure","Java Fundamentals: The Java Language","Creating a Simple App","Introducing Packages","0:37","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=6&mode=live&start=37.867544&noteid=8088385d-3106-4045-8f89-5da987565769"
"package naming conventions:\n- all lowercase\n- use reversed domain name to assure global uniqueness\nexample: pluralsight.com -> com.pluralsight\n- add further qualifiers to assure uniqueness within a company/group\nexample: com.pluralsight.myproject (or deptname.myproject)","Java Fundamentals: The Java Language","Creating a Simple App","Introducing Packages","1:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=6&mode=live&start=64.176921&noteid=73dabb11-0146-47ae-a81b-d30f823d8886"
"if class is named Main but is in com.pluralsight.myproject package, then class is now com.pluralsight.myproject.Main","Java Fundamentals: The Java Language","Creating a Simple App","Introducing Packages","4:16","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=6&mode=live&start=256.931381&noteid=6dde2355-1a22-4da2-bea5-87d4f4587cc9"
"Java requires no correlation between package names and source code file structure, but IDEs do","Java Fundamentals: The Java Language","Creating a Simple App","Introducing Packages","4:54","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=6&mode=live&start=294.269855&noteid=515afcf6-d874-4755-ac0d-d323c8697692"
"in IDEs, each part of the package name need to be their own subfolder\nex. com.pluralsight.myproject.Main goes as follows\nsrc->com->pluralsight->myproject->Main","Java Fundamentals: The Java Language","Creating a Simple App","Introducing Packages","6:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=6&mode=live&start=362.276238&noteid=537947d2-e335-4314-ad0c-b89f533c7e41"
"with packages, when in terminal, instead of having to go all the way to the directory that contains the class file, you can just go to directory that contains the first subfolder of the package\nexample: package is com.pluralsight.getorganized.Main and the Organized directory contains the com directory\n- we can run java com.pluralsight.getorganized.Main while only inside the Organized directory (as opposed to having to go deeper) and it'll run the Main.class file even though it's not directly inside the Main directory, because technically the class name is now com.pluralsight.getorganized.Main\n(similar for NetBeans)","Java Fundamentals: The Java Language","Creating a Simple App","Demo: Packages","3:22","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=7&mode=live&start=202.73884&noteid=9a1e642f-4151-4dc8-ab87-03e68c7b86ea"
"IntelliJ and NetBEans have different output file structures","Java Fundamentals: The Java Language","Creating a Simple App","Creating and Running a NetBeans Project","4:21","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=8&mode=live&start=261.14958&noteid=ed672cb0-5ef7-4934-82bf-cad45577674d"
"Packages provide organization:\n- assure uniqueness\n- Most IDE's tie source code file structure to package names","Java Fundamentals: The Java Language","Creating a Simple App","Summary","1:30","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m2&clip=9&mode=live&start=90.408772&noteid=129d5158-bf3b-4157-a1b7-93f404b3aa5c"
"Java is strongly typed: when we declare the name of the variable, we have to declare the type as well","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Variables","0:28","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=1&mode=live&start=28.747956&noteid=54a8a959-0bac-4d38-8ec5-24161d38babd"
"Java Variable Naming follows the Camel Case convention:\n\n1 - first letter is lowercase\n2- start of each after the first is uppercase\n3 - all other letters are lower case","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Variables","2:06","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=1&mode=live&start=126.936729&noteid=6e935aeb-fe68-429c-961a-7d6a9291a337"
"Primitive Data Types: built into the language\n- Integer\n- Floating Point\n- Character\n- Boolean\n","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Data Types","0:13","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=2&mode=live&start=13.938662&noteid=e21ef341-6946-4d81-9995-c07e2b9da5ed"
"4 Integer Types:\n- byte (8 bits)\n- short (16 bits)\n- int (32 bits)\n- long (64 bits) must end with an L","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Data Types","0:54","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=2&mode=live&start=54.760882&noteid=72c49254-603d-47ad-a0b8-e7c218f21dbc"
"Floating Points:\n- stores values containing a fractional portion\n\nFloating Points Types:\n- float (32 bits) must end with an f\n- double (64 bits) with or w/o 'd' at end","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Data Types","2:56","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=2&mode=live&start=176.127829&noteid=2e5028c5-2fca-4b50-866c-e332e6c436fa"
"Character\n- char stores a single Unicode character (literal values placed between single quotes)","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Data Types","3:33","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=2&mode=live&start=213.368021&noteid=20a60905-0467-4523-9471-5960ca59768d"
"Boolean\n- true\n- false","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Data Types","4:20","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=2&mode=live&start=260.212552&noteid=799a5951-a7a2-4a78-b5d4-ddeae85cc040"
"Primitive Types are stored by-value:\n- each primitive type variable has its own separate copy of the data\n\nGiven the code:\nint firstVal = 100;\nint otherVal = firstVal;\nfirstVal = 50;\n\n- firstVal is set to 100\n- then the value of firstVal is copied into otherVal, making the value of otherVal 100 as well\n- finally, the value of firstVal is now changed to 50, however the value of otherVal is STILL 100\n","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Primitive Types are Stored By-value","0:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=3&mode=live&start=8.974704&noteid=58910ab0-4a2a-4698-8ff0-9028b6634169"
"Arithmetic Operators:\n\nBasic Operators: +,-,*,/,%\n\nNote: Integer Division\n\nPrefix/Postfix Operators: ++,--\n\nPrefix (before) applies applies operation before returning value\n\nPostfix (after) applies applies operation after returning value\n\nCompound Assignment Operators:\n+= ,-=, *=, /=, %=","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Arithmetic Operators","0:16","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=4&mode=live&start=16.344208&noteid=da36cf21-44ec-4f5a-9d4e-62ff4acc3cff"
"Operator Precedence:\n- Postfix: x++, x--\n- Prefix: ++x, --x\n- Multiplicative: *, /, %\n- Additive: +, -\n\nOperators of equal precedence are evaluated left-to-right\n\nCan override precedence with parentheses; parentheses are read from the inside out","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Operator Precedence","0:20","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=5&mode=live&start=20.446859&noteid=eb9a320c-279b-4b8a-962b-1f6872ab8526"
"Type Conversions:\n\nImplicit Type Conversions\n- conversions performed automatically by the compiler because moving to a wider data type\n- Mixed integer sizes: uses largest integer in equation\n- mixed floating point sizes: uses double\n- mixed integer and floating point: uses largest floating point in equation\n- Example:\nint iVal = 50;\nlong LVal = iVal;\n\nExplicit Type Conversions\n- conversions performed explicitly in code with cast operator, widening and narrowing conversions\n- floating point to integer drops fraction\n- use caution with narrowing conversions\n- integer to floating point can lose precision\n- Example:\n long LVal = 50;\n int iVal = (int) LVal;","Java Fundamentals: The Java Language","Variables, Data Types, and Math Operators","Type Conversion","0:15","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m3&clip=7&mode=live&start=15.981159&noteid=db19f28b-f18c-4589-b07a-2d71bfb1d677"
"Relational Operators:\n>\n<\n==\n!=\n>=\n<=","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Conditional Logic and Relational Operators","2:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=1&mode=live&start=128.118395&noteid=d8eeb389-cc96-4385-8e3d-c4a07314f1e8"
"Conditional Assignment:\n- Assign a value to a variable based on the result of a condition\nresult=condition?true-value : false-value ;\n- if the condition is true, then\nresult = true-value\n- if the condition is false, then \nresult = false-value\n","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Conditional Assignment","0:15","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=2&mode=live&start=15.352939&noteid=1239b87d-2a59-478d-bb61-b4363e7e9b6d"
"If-Else:\n- if (condition-1)\ntrue-statement-1;\nelse if(condition-2)\ntrue-statement-2;\nelse\nfalse-statement;","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","If-else Statement","0:49","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=3&mode=live&start=49.440523&noteid=f2eb6a0e-dfea-47ac-9ae2-ee1037ae582c"
"A block statement groups statements into a compound statement\n- essentially, if you surround your if statements with brackets, you can make a ton of stuff happen only if that condition is proven true and ignore that entire block of code otherwise","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Block Statements","0:37","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=4&mode=live&start=37.266513&noteid=02579bbb-a61e-4e47-b123-2d151ac3d20e"
"Multiple variable declarations can be done on one line for the same type:\n- Example: int v1=10,v2=4,diff;","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Block Statements","2:32","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=4&mode=live&start=152.745411&noteid=560efca7-924d-410f-8fe2-82e7094df3b4"
"A variable declared within a block is NOT visible outside of the block.\n- a variable's range of visibility is known as the variable's scope","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Block Statements and Variable Scope","0:22","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=6&mode=live&start=22.041101&noteid=b110e860-41b5-4175-8e13-cd4076149348"
"Logical Operators:\n- And - & - True if true&true\n- Or - | - True if false|true,true|true,true|false\n- Exclusive or (XOR) - ^ - True if false|true,true|false\n- Negation - ! - True if !False\n\nConditional Logical Operators:\n- Conditional And - && - True if true&true\n- Conditional Or - || - True if false|true,true|true,true|false\n\nOnly execute the right side if it is necessary to determine the result:\n- && only executes the right side if the left side is true\n- || only executes the right side if the left side is false","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Logical Operators","0:30","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=7&mode=live&start=30.256506&noteid=f17bb5ce-38d9-4c14-b60d-c0006f62200b"
"Main 3 Types of Loops:\n- While Loop\n - while(condition)\n  statement;\n- For Loop\n - for(initialize;condition;update)\n    statement;\n- Do While Loop\n - statement always executes at least once\n - do\nstatement;\nwhile(condition);","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Loops","0:25","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=10&mode=live&start=25.129755&noteid=2e8f552a-f811-45b3-9406-f8938c1ee08e"
"Arrays ([]):\n- provides an ordered collection of elements\n\nFor-each loop:\n- executes a statement once for each member in an array\n- for(loop-variable-declaration:array)\n statement;\n- handles getting collection length\n- handles accessing each value\n- loop-variable-declaration refers to a variable of the same type as the array variables used to traverse the array, essentially a pointer. So if it were an array of ints called arrint, the loop would be for(int ptr : arrint)","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Arrays","0:34","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=11&mode=live&start=34.812697&noteid=9e35688b-d47c-44ac-a829-2eba33e0cc4a"
"Switch\n- transfers control to a statement based on a value\n - simplifies testing against mltiple possible matches\n- switch(test-value){\n case value-1:\n statements\ncase value-n:\nstatements\ndefault:\nstatements\n}\n- a match can execute more than one statement; as a matter of fact, unless you use the break keyword, all case statements that follow the case you first reached will be executed\n- can optionally include default to handle any unmatched values\n- it's good programming practice to include a break at the end of each case in a switch statement\n- of the primitive types discussed up until this point, switch can only be used with char and int","Java Fundamentals: The Java Language","Conditional Logic, Looping, and Arrays","Switch Statement","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m4&clip=13&mode=live&start=2.48852&noteid=7877e91c-1888-4aec-b6d9-4cbe81bf6a7f"
"- Java is an objected oriented language\n - objects encapsulate data, operations, and usage semantics\n - allows storage and manipulation details to be hidden\n- Classes provide a structure for describing and creating objects","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Classes","0:10","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=1&mode=live&start=10.103865&noteid=a5d21c17-532a-4a51-8e76-147035f6e00e"
"Classes:\n- a class is a template for creating an object \n - declared with the class keyword followed by the class name\n - Java source file name normally has same name as class\n - body of class contained within brackets\n - a class is made up of both state and executable code\n      - fields: store object state\n      - methods: executable code that manipulates state and performs operations\n      - constructors: executable code used during object creation to set the initial state\n\n","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Classes","1:31","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=1&mode=live&start=91.915991&noteid=56f4fd7c-4b05-485e-9c49-59e66616b0d9"
"Using classes:\n- use the new keyword to create a class instance\n  - object_name ariel = new object_name();\n  - allocates the memory described by the class\n  - returns a reference to the allocated memory, so ariel is not the object itself, but a reference to the object","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Using Classes","0:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=2&mode=live&start=4.427415&noteid=0f71c739-51fd-4a85-bab5-13043509a76d"
"Classes are reference types:\n- ariel1 and ariel2 are initially pointing to two different objects\n- but if you set ariel2=ariel1, then ariel2 simply points to what ariel1 is pointing to from now on, and since there is nothing pointing to what was ariel2's object, that object now disappears\n- so now if you make a change to one of ariel1's fields, ariel2's fields will be changed as well, because you now set ariel2 to point to the same object ariel1 is pointing to\n- this is different from setting primitive types equal to each other, because there values are copied, here references are copied/moved around","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Using Classes","1:36","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=2&mode=live&start=96.088575&noteid=3212b05b-7f50-481b-a5b1-275b30ac9990"
"Encapsulation and Access Modifiers:\n - the internal representation of an object is generally hidden- this concept is known as encapsulation\n- Java uses access modifiers to achieve encapsulation","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Encapsulation and Access Modifiers","0:07","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=3&mode=live&start=7.854836&noteid=3ee19dbb-a1f0-413a-abce-48ff5ff5a52a"
"Basic Access Modifiers:\n- no access modifier: visible only within its own package (aka package private)\n- public: visible everywhere\n- private: visible only within its own class","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Encapsulation and Access Modifiers","1:15","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=3&mode=live&start=75.86918&noteid=5ce54c89-5f0d-4c8f-a252-51f2e4e01582"
"Example: class name and constructor as public, fields as private\nNote: public classes have to be inside of a source file with the same name, but not required if not public","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Applying Access Modifiers","1:45","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=4&mode=live&start=105.443171&noteid=da1a7bbb-173a-4cd1-b42b-863825722539"
"Naming classes:\n- same as variables except first letter of every word, including the first word, is uppercase (Pascal Case)\n- use simple, descriptive nouns (Person, BankAccount)\n- avoid abbreviations unless more common than actual word","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Naming Classes","0:07","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=5&mode=live&start=7.296733&noteid=f3d800d6-b249-4730-a44c-868b20584e07"
"Method Basics:\n- executable code that manipulates state and performs operations\n- same naming conventions as variables, but should be a verb or action\n- must have a return type, or void if none\n- typed parameter list can be empty\n- body contained within brackets\n- return-type name (typed-parameter-list){\nstatements;\n}","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Method Basics","0:09","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=6&mode=live&start=9.305027&noteid=55b199e3-ef7f-4966-9e61-c9e4d15f9bab"
"Exiting from a Method:\n- 3 reasons for why it would exit:\n  - the end of the method is reached\n  - a return statement is encountered\n  - an error occurs\n- unless there's an error, control returns to the method caller\n- returns can be placed anywhere inside the method ","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Exiting from a Method","0:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=7&mode=live&start=4.288998&noteid=dbfa2ca1-dcac-4f3e-be6c-8f70ceac27a6"
"Method return values:\n- a method returns a single value:\n- primitive value\n- reference to object\n- reference to array (since arrays are objects)","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Method Return Values","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=8&mode=live&start=3.353739&noteid=73418bec-b798-4dee-9e9d-e74badb03b40"
"Special references - this and null\n- Java provides special references with predefined meanings\n  - this is an implicit reference to the current object\n     - useful for reducing ambiguity\n     - allows an object to pass itself as a parameter\n - null is a reference literal\n     - represents an uncreated object\n     - can be assigned to any reference variable, and can be compared with the current value of a reference variable to determine if the object refers to anything or not\n    - used to say that this variable isn't pointing to anything at the moment","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Special References: this and null","0:06","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=9&mode=live&start=6.547616&noteid=aa6b2ea8-b870-47a4-a7d8-507c4e9ef0b8"
"Field encapsulation:\n- in most cases, a class' fields should not be directly accessible outside of the class\n-  helps to hide implementation details\n- use methods to control field access\n","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Field Encapsulation, Accessors, and Mutators","0:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=11&mode=live&start=8.089875&noteid=c7c266a5-12da-4038-9a4c-af0c73039ba2"
"Accessors and Mutators aka Getters & Setters:\n- use the accessor/mutator aka getter/setter pattern to control field access\n  - accessor/getter retrieves field value\n      - method name: getFieldName\n      - it's public\n - mutator/setter modifies field value\n      - method name: setFieldName\n      - it's public\n","Java Fundamentals: The Java Language","Representing Complex Types with Classes","Field Encapsulation, Accessors, and Mutators","0:45","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m5&clip=11&mode=live&start=45.526975&noteid=de96aee1-89e4-42f4-b714-5f540d706578"
"Establishing Initial State:\n- when an object is created, it is expected to be ina useful state\n- often the default state established by Java is not enough\n- the object may need to set values or execute code","Java Fundamentals: The Java Language","Class Initializers and Constructors","Establishing Initial State","0:14","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=1&mode=live&start=14.25799&noteid=eef4376b-93ec-41de-9f64-d2a24a2c786a"
"3 Possible Mechanisms for Establishing Initial State:\n- field initializers\n- constructors\n- initialization blocks","Java Fundamentals: The Java Language","Class Initializers and Constructors","Establishing Initial State","0:37","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=1&mode=live&start=37.43526&noteid=c7c8201f-f3f4-42d7-bc0b-56de6625f4da"
"Field Initial State:\n- a field's initial state is established as part of object construction\n  - fields receive a Zero value by default\n      - 0/false/null depending on type","Java Fundamentals: The Java Language","Class Initializers and Constructors","Field Initial State and Initializers","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=2&mode=live&start=3.639203&noteid=11eefa89-664c-4d58-bf32-d79516d8bbcd"
"Field Initializers:\n- allow you to specify a field'sintial value as part of its declaration\n   - can be a simple assignment, literally just setting the field to a specific value when you first implement the class\n   - can be an equation\n   - can reference other fields\n   - can be a method call\n","Java Fundamentals: The Java Language","Class Initializers and Constructors","Field Initial State and Initializers","1:12","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=2&mode=live&start=72.546968&noteid=0a139966-eefd-4afa-9084-76abb3357d54"
"Constructor:\n- executable code used during object creation to set the initial state\n- NOT A METHOD, DOES NOT HAVE A RETURN TYPE\n- every class has at least one constructor\n   - if there is no explicit constructor, Java provides a basic one that does nothing but create the instance of the class\n- a class can have multiple constructors, but each one has to have a different parameter list (different number of and types of parameters)\n- if you implement a constructor on your own, you are then responsible for ALL constructors, i.e. Java's automatic constructor will not exist","Java Fundamentals: The Java Language","Class Initializers and Constructors","Constructor and Adding Multiple Constructors","0:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=3&mode=live&start=1.018808&noteid=89f7f69e-4024-4bea-88bf-3ce44607335c"
"Chaining Constructors:\n- one constructor can call another\n   - use the this keyword followed by the parameter list, which will then call the constructor with that parameter list. Ex. this(random_var)\n   - the call to the other constructor must be the first line in the constructor you are currently implementing","Java Fundamentals: The Java Language","Class Initializers and Constructors","Chaining Constructors and Constructor Visibility","0:14","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=4&mode=live&start=14.948753&noteid=32dba360-7ab2-4067-a4af-9803e8672592"
"Constructor Visibility:\n- use access modifiers to control constructor visibility\n   - limits what code can perform specific creations\n   - can make constructors private to make sure they can't be called outside the class","Java Fundamentals: The Java Language","Class Initializers and Constructors","Chaining Constructors and Constructor Visibility","2:35","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=4&mode=live&start=155.621508&noteid=ce1be666-e982-4c8d-9f24-176716fe64dd"
"Initialization Blocks:\n- initialization blocks are shared across all constructors\n   - executed as if the code were placed at the start of each constructor\n   - enclose statements in brackets outside of any method or constructor\n   - if you implement more than one initialization block, they will run in the order that they are implemented from top to bottom\n- Example:\npublic class Flight{\nprivate int passengers, flightNumber,seats=150;\nprivate char flightClass;\nprivate boolean[] isSeatAvailable;\n\n{\nis SeatAvailable = new boolean [seats];\nfor(int i=0;i,seats;i++)\nisSeatAvailable[i] = true;\n}\n\npublic Flight(){}\n\npublic Flight(int flightNumber){\nthis.flightNumber = flightNumber;\n}\n\npublic Flight(char flightClass){\nthis.flightClass = flightClass;\n}\n\n\nTHE INITIALIZATION BLOCK (WHICH IS THE CODE SURROUNDED BY BRACKETS RIGHT BELOW THE FIELD DECLARATIONS AND RIGHT ABOVE THE CONSTRUCTOR DECLARATIONS) IS IMPLEMENTED AT THE BEGINNING OF EACH CONSTRUCTOR THAT FOLLOWS\nSO IN THIS CASE, ALL THE SEATS ARE SET TO AVAILABLE FOR ALL 3 CONSTRUCTORS AT THE VERY BEGINNING OF EACH ONE","Java Fundamentals: The Java Language","Class Initializers and Constructors","Initialization Blocks","0:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=6&mode=live&start=4.567488&noteid=2372c479-e51c-4254-acad-9c61a49168c9"
"Initialization and Construction Order:\n - Constructor code overrides Initialization Block code which overrides Field Initialization code\n    - essentially, if you set the value of a parameter var = 1 in the field initialization,var = 2 in the initialization block, and var = 3 in the constructor, the value of var in the initialization block will override the value of var in the field initialization, and the value of var in the constructor will override the value of var in the initialization block, making the official value of var 3.","Java Fundamentals: The Java Language","Class Initializers and Constructors","Initialization and Construction Order","0:11","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m6&clip=7&mode=live&start=11.658806&noteid=ff14942a-5a09-4561-a93b-221d67856a7f"
"Parameter Immutability:\n- parameters in Java are passed by-value = parameters are passed by making a copy of the value\n- changes made to passed value are not visible outside of method, whether it's a primitive type or a reference object such as a class\n- however, changes made to MEMBERS of passed class instances ARE visible outside of method\n   - essentially, if you make changes to a class inside a function, the changes to that class' MEMBERS will STICK","Java Fundamentals: The Java Language","A Closer Look at Parameters","Parameter Immutability","0:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m7&clip=1&mode=live&start=4.875664&noteid=88a10a6f-ab44-4153-9b87-6f0d944f7af2"
"Overloading:\n- when a class has multiple versions of its constructor or methods\n- each constructor and method must have a unique signature, made up of 3 parts\n   - number of parameters\n   - type of each parameter\n   - must have same name (only applies to methods)\n- while constructors must call other constructors in the very first line, methods can call other versions of the same method at any point in the implementation\n- if method call contains parameter not mentioned in any of the possible method versions, will try to convert/cast itself to work for one of the possible methods (such as a short being converted to an int because the function takes an int parameter, widening conversions are legal, narrowing conversions are illegal), and if nothing is possible, error","Java Fundamentals: The Java Language","A Closer Look at Parameters","Overloading","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m7&clip=2&mode=live&start=2.965941&noteid=6e658c9d-5b1a-493d-8cd4-580e7b849b2b"
"Variable Number of Parameters:\n- a method can be declared to accept a varying number of parameter values\n  - in order to do so, when you declare a parameter, place an ellipse after the parameter type\n  - can only be used on the last parameter for a method\n  - the variable number of parameters are handled as an array\n    - so essentially: \nPassenger [] list = Passenger ... list,\n=> f.addPassengers( new Passenger[] {janet,john}); = f.addPassengers(janet,john);","Java Fundamentals: The Java Language","A Closer Look at Parameters","Variable Number of Parameters","0:12","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m7&clip=5&mode=live&start=12.391285&noteid=18690078-5e89-4ca2-82c8-5bc476b79aae"
"Class Inheritance:\n- a class can be declared to inherit (aka derive) from another class using the ""extends"" keyword\n- the derived class has the characteristics of the base class, but you can add specializations to create more capabilities\n- if a class extends another class, it can use that base class' methods and fields, as well as create its own\n- instances of the derived class can be assigned to base class typed references (ex. if CargoFlight extends Flight, in addition to \nCargoFlight cf = new CargoFlight() being legal, the following is also legal:\nFlight f = new CargoFlight() )  \n     - Note, however, that if you do that, you only have access to the capabilities of the Flight class, and not of the CargoFlight class\n     - Value of this is that it allows us to perform Flight-based actions without being concerned about the specific type of the instance\n- if the derived class adds a field that has the same name as a field in the base class, it will actually hide the base class version of the field.\n   - but be careful when doing the equivalent of \nFlight f = new CargoFlight()\nbecause then f's value for the field will follow the rules of the Flight class, even though it is assigned as a CargoFlight\n- if you have a derived class with a method with the same signature as a base class method, it will override it\n   - so if we do the equivalent of  \nFlight f = new CargoFlight() , \nand both Flight and CargoFlight have the same method, the CargoFlight version of the method will override the Flight version because f was assigned to a new CargoFlight() and NOT to a new Flight()\n- all messages are automatically overrideable\n- use the ""@Override"" keyword right above the derived class version of the method to make sure the compiler knows that you are trying to override the base class version of that method\n\n","Java Fundamentals: The Java Language","Class Inheritance","Inheritance Basics and Typed References","0:09","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=1&mode=live&start=9.379861&noteid=523a27ed-a6ae-4415-b317-5a8edb16cfaf"
"Object Class\n- the root of the Java class hierarchy\n- every class has the characteristics of the Object class\n- useful for declaring variables, fields, and parameters that can reference any class or array instance\n- essentially a universal reference type\n- defines a number of methods are inherited by all objects\n","Java Fundamentals: The Java Language","Class Inheritance","Object Class","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=3&mode=live&start=3.023099&noteid=5fe72745-d69f-409f-a0b2-390cd1a53059"
"Inheriting from Object:\n- every class inherits directly or indirectly from the Object class\n- by implication, every class extends the Object class\n- ""o instanceof CargoFlight"": boolean method that confirms whether Object o is an instance of the CargoFlight class","Java Fundamentals: The Java Language","Class Inheritance","Object Class","0:49","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=3&mode=live&start=49.891663&noteid=18bd9e04-8f25-420f-a3be-74a792be05f4"
"Object Class Methods:\n- clone: create a new object instance that duplicates the current instance\n- hashCode: get a hash code for the current instance\n- getClass: return type information for the current instance\n- finalize: handle special resource cleanup scenarios\n- toString: return string of characters representing the current instance\n- equals: compare another object to the current instance for equality","Java Fundamentals: The Java Language","Class Inheritance","Object Class","5:18","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=3&mode=live&start=318.635665&noteid=c247e9b7-3d83-40ea-8af0-5bf1ae182989"
"Equality:\n- what does it mean to be equal?\n- both ""=="" and ""equals"" do a reference equals test: do both of these references point to the exact same object instance?\n- we can, however, override the equals method\n- Flight example: \n@Override\npublic boolean equals(Object o){\nif(!(o instanceof Flight)){\nreturn false; }\nFlight other = (Flight)o;\nreturn flightnumber == other.flightNUmber && flightclass == other.flightClass; }\n   - ""Flight other = (Flight)o"" is required because in order to override the method signature has to be exactly the same, but we want to work with only Flight objects, so we need to cast ""o"" as a Flight and assign it to a temp variable\n   -  ""if(!(o instanceof Flight)){\nreturn false; }"" is required to ensure that the object passed into this version of the equals method MUST be a Flight","Java Fundamentals: The Java Language","Class Inheritance","Equality","0:04","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=4&mode=live&start=4.932069&noteid=be01e110-d401-4dfc-8cbc-ef73750505a5"
"Special Reference: super\n- similar to ""this"", ""super"" is an implicit reference to the current object\n  - the difference, though, is that ""super"" treats the object as if it is an instance of its base class\n  - useful for accessing base class members that have been overriden\n- Same Flight Example:\n@Override\npublic boolean equals(Object o){\nif(super.equals(o){\nreturn true;}\nif(!(o instanceof Flight)){\nreturn false; }\nFlight other = (Flight)o;\nreturn flightnumber == other.flightNUmber && flightclass == other.flightClass; }\n- ""if(super.equals(o){ return true;}""\nis used to check if the two references do happen to actually point at the exact same object, in which case we would want to use the ORIGINAL version of the equals function (which checks that the references are pointing to the exact same object), requiring that we say \n""super.equals"" in order to utilize the Object class version of the equals function instead of the Flight class version","Java Fundamentals: The Java Language","Class Inheritance","Special Reference: Super","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=5&mode=live&start=3.230427&noteid=d17b8388-0880-4313-a801-4db04dd0def2"
"Controlling Inheritance & Overriding:\n- by default, all classes can be extended\n- all derived classes have the option to use or override inherited methods\n- however, a class can change these defaults\n- use ""final"" to prevent inheriting and/or overriding\n- use ""abstract"" to require inheriting and/or overriding","Java Fundamentals: The Java Language","Class Inheritance","Using Final and Abstract","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=6&mode=live&start=2.178463&noteid=5743efef-5554-4895-ace0-ec1d1e43d995"
" Using Final:\n- ""public final"" / ""final public"" class ClassName makes it that the class ClassName CANNOT be extended\n- ""public final"" returntype MethodName() makes it that the method MethodName CANNOT be overriden","Java Fundamentals: The Java Language","Class Inheritance","Using Final and Abstract","0:05","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=6&mode=live&start=5.985472&noteid=d712ea85-b4f3-444a-898a-d32874097af5"
"Using Abstract:\n- if you have an abstract method you HAVE to mark the entire class as abstract\n- ""public abstract"" returntype MethodName() "";"" makes it that the method MethodName MUST be overriden, as we are INCLUDING a ; at the end to emphasize that we are not including the code for MethodName, but rather that the inheriting class must override it.\n   - note that MethodName can still be referred to in the original class as a function that does something, so long as when the inheriting class extends the original class, MethodName is overriden and given an actual body of code","Java Fundamentals: The Java Language","Class Inheritance","Using Final and Abstract","2:46","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=6&mode=live&start=166.193603&noteid=9bee186f-d927-4ba0-a0ad-1906595b789f"
"Inheritance and Constructors:\n- In Java, constructors are not inherited\n    - each class is always responsible for defining its own constructors\n- a derived class, however, must always call one of the base class constructors, and it will always call a base-class constructor, EVEN IF we don't specify one in the constructor's body of code\n    - that call DOES NOT have to be explicit; by default, the base class' no-argument constructor is called\n    - can explicitly call a base class constructor using ""super(correct parameter list of the base class constructor)""\n         - must be first line of constructor though\n","Java Fundamentals: The Java Language","Class Inheritance","Inheritance and Constructors","0:10","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m8&clip=7&mode=live&start=10.673285&noteid=dd7e569e-9666-46f2-98f7-7c5c4236ca27"
"String class:\n- stores a sequence of unicode characters\n    - stored using UTF-16 encoding, which means it can store essentially any character\n- literal strings are enclosed in """" """"\n- values can be concatenated using \n=/+=\n- String objects are immutable - once it was created, it can never be changed, so anything that changes that value requires that a new instance of the String object be created\n     - so even if you were to just concatenate one more char, you're actually pointing to a brand new string that happens to have what you originally had + the extra char","Java Fundamentals: The Java Language","More About Data Types","String Class","0:10","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=1&mode=live&start=10.219009&noteid=f8e77813-9369-47f8-b72c-f94ccfd56c23"
"Select String Class Methods:\n- Length: length\n- String for non-string: valueOf\n- Create new string(s) from existing strings:\n    - concat, replace, toLowerCase,toUpperCase,trim,split\n- Extract substring: charAt, substring\n- Test substring: \n    - contains, endsWith,startsWith,indexOf, lastIndexOf\n- Comparison: \n    - compareTo,compareToIgnoreCase,isEmpty,equals,equalsIgnoreCase","Java Fundamentals: The Java Language","More About Data Types","String Class","2:23","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=1&mode=live&start=143.29692&noteid=4a7ee454-b675-4228-8507-7c093ecab207"
"String equality:\n- the equals method does a char by char comparison of the two values and if they all match, it returns true\n- the ""intern"" method gives back a canonicalized reference of a string value\n- the ""intern"" method will return back one specific string object for each string value \n     - Example: if you have 3 different strings a,b,c with the value ""hello"",\na!=b!=c BUT \na.intern() == b.intern() == c.intern\n- the intern method assures that two strings with the same value will reference the exact same object, which then allows us to use the ""=="" operator to do the comparison, which is good because ""=="" is cheaper than ""equals"" comparing char by char\n- series of one-off comparisons: equals\n- a lot of comparisons: intern","Java Fundamentals: The Java Language","More About Data Types","String Equality","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=2&mode=live&start=3.449473&noteid=480272f0-e0c2-4b91-aeab-6eae6bdbb3e7"
"Converting Non-strings to Strings:\n- String.valueOf provides overrides to handle most types\n- conversions often happen implicitly\n- class conversions are controlled by the class' toString method (which we implement by overriding the Object class' version of toString)","Java Fundamentals: The Java Language","More About Data Types","String Representation of Non-string Values","0:05","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=3&mode=live&start=5.329987&noteid=26c3df24-1657-41b8-8db9-6eea4b46f136"
"StringBuilder:\n- provides a mutable string buffer, providing us with an efficient way to manipulate strings\n    - for best performance, pre-size the buffer by providing initial capacity\n    - will grow automatically if you exceed the capacity, but try to get the pre-size correct, since expanding has overhead\n- StringBuilder sb = new StringBuilder(pre-size buffer)\n- most common methods:\n    - append(string): add to the end\n    - insert(position, string): add at the given position, moving everything to the right\n- to get the actual string at the end:\nString message = sb.toString()","Java Fundamentals: The Java Language","More About Data Types","StringBuilder Class","0:00","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=4&mode=live&start=0.325917&noteid=e557a6c5-80cd-44f3-94ff-cdd932517920"
"Classes vs. Primitives:\n- Classes:\n    - provide convenience\n    - common interaction through Object class\n    - fields and methods specific to the type\n    - incurs an overhead cost\n- Primitives:\n    - provide efficiency\n    - cannot be treated as Object\n    - cannot expose fields or methods\n    - lightweight","Java Fundamentals: The Java Language","More About Data Types","Primitive Wrapper Classes and Type Conversions","0:06","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=5&mode=live&start=6.906059&noteid=ba8d0417-a5a2-4e1c-932f-94c76dba23e1"
"Primitive Wrapper Classes:\n- capabilities and overhead of classes\n- hold primitive values\n- they are legit classes, so they refer to the Object class\n- each of the primitive types has a corresponding wrapper class\n    - boolean primitive type has wrapper type Boolean\n    - char has Character\n    - all numeric values have Number, but it's split further so that:\n       - int has Integer\n       - double has Double\n       - same for byte (Byte), short (Short), long (Long), float (Float)\n    - each can be treated as objects, and have fields and methods associated with them that are particular to that type\n- note that all primitive wrapper classes are IMMUTABLE, like working with strings","Java Fundamentals: The Java Language","More About Data Types","Primitive Wrapper Classes and Type Conversions","1:34","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=5&mode=live&start=94.935074&noteid=7667b56e-9b02-47c7-93e5-c6b86d0491ef"
"Wrapper Class & Primitive Conversion:\n- Java provides a number of ways to handle conversions\n    - common conversions are handled automatically\n- wrapper classes provide methods for explicit conversions:\n   - primitive to wrapper: use valueOf (this process is known as boxing)\n   - wrapper to primitive: use Integer.intValue/Double.doubleValue/ etc (this process is known as unboxing)\n   - String to primitive: use Double.parseDouble/Integer.parseInt/etc (gives you back the primitive value corresponding to the parsed string)\n   - String to wrapper: use Double.valueOf/Integer.valueOf/etc\n(gives you back a reference to a wrapper class)","Java Fundamentals: The Java Language","More About Data Types","Primitive Wrapper Classes and Type Conversions","3:12","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=5&mode=live&start=192.662713&noteid=1e0e669c-7dfb-4a17-be23-0b02f54c3b8c"
"Using Wrapper Classes:\n- we can treat primitive types as objects\n- null references\n   - given flightNumber and flightClass as a primitive int and char respectively, it's hard to tell if they were actually set in the first place because you can't check if they're equal to null; instead you'd only be able to check if flightNumber>0 and hope for the best with flightClass\n   - but if you change them to Integer flightNumber and Character flightClass, you can then check if they were set by checking if they are != null, and printing them out is simple because Java will automatically convert them to the primitive form to print","Java Fundamentals: The Java Language","More About Data Types","Using Primitive Wrapper Classes","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=6&mode=live&start=3.677095&noteid=8e548b5a-7e74-4a85-a732-6026015c2b96"
"Examples of Wrapper Class Members:\n- Byte/Short/Integer/Long: \n   - MIN_VALUE, MAX_VALUE,bitCount,toBinaryString\n- Float/Double:\n   - MIN_VALUE,MAX_VALUE,isInfinite,isNan\n- Character: \n  - MIN_VALUE,MAX_VALUE,isDigit,isLetter\n- Boolean:\n - TRUE,FALSE","Java Fundamentals: The Java Language","More About Data Types","Using Primitive Wrapper Classes","2:34","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=6&mode=live&start=154.332899&noteid=c7697141-fa71-4b10-8f78-a2c85465b6a1"
"Wrapper Class Equality:\n- usually we use ""equals"" because wrapper classes are similar to strings\n- but for the following ranges, boxing conversions always return the same wrapper class instance, so you can use ""=="":\n- int/short/byte: -128 to 127\n- char: 0x0000 to 0X00ff\n- boolean: true, false\n","Java Fundamentals: The Java Language","More About Data Types","Wrapper Class Equality","2:22","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=7&mode=live&start=142.903888&noteid=03c9f48f-b727-42b2-9500-8efd1da3b492"
"Final Fields:\n- marking a field as final prevents it from being changed once assigned\n   - a simple final field must be set during the creation of an object instance\n    - can be set with field initializer, initialization block, or constructor\n    - Example: ""private final int freeBags;"" would mean that once the value of freeBags is set for the first time by the constructor, any time somebody tries to change it after that, a compile error will be thrown\n- adding the static modifier makes a final field a named constant\n    - cannot be set by an object instance\n   - Example: ""static final int MAX_FAA_SEATS = 550;"" means that MAX_FAA_SEATS will have the value 550 in ALL Flight instances\n  - are by convention all uppercase\n  - useful in order to avoid having to put literal numbers/characters inside of our code and one change to the variable while implementing will change it for all lines of code it's in instead of having to change each line individually","Java Fundamentals: The Java Language","More About Data Types","Final Fields and Enumeration Types","0:11","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=8&mode=live&start=11.462344&noteid=05f96ebd-8e77-4dd1-8c23-8877df1b57fe"
"Enumeration Types:\n- enumeration types are useful for defining a type with a finite list of valid values\n  - declare with enum keyword\n  - provide a comma-separated value list\n  - Example: \npublic enum FlightCrewJob{\nPilot,\nCoPilot,\nFlightAttendant,\nAirMarshal\n}\n      - and now we can use FlightCrewJob as a TYPE\n      - to set a FlightCrewJob value: \n""CrewMember judy = new CrewMember(FlightCrewJob.CoPilot);""\n      - to change a FlightCrewJob value: ""Judy.setJob(FlightCrewJob.Pilot);""\n      - note that to refer to any of the values, you need FlightCrewJob.Pilot/CoPilot/FlightAttendant/AirMarshal\nAKA enumname.enumvalue","Java Fundamentals: The Java Language","More About Data Types","Final Fields and Enumeration Types","2:51","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m9&clip=8&mode=live&start=171.327513&noteid=6bfab4d1-b0aa-4f92-a176-1d1eb2193a33"
"Error Handling with Exceptions:\n- error handling needs to be implicit in application development\n   - the traditional approach of checking error codes/flags  is too intrusive\n- Exceptions provide a non-intrusive way to signal errors\n   - try/catch/finally provides a structured way to handle exceptions\n      - the try block contains the     ""normal"" code to execute, and the block executes to completion UNLESS  an exception is thrown\n      - the catch block contains the error handling code, and executes ONLY if the matching exception is thrown\n      - the finally block contains cleanup code if needed, and runs in all cases following the try or catch blocks - guaranteed to run no matter what\n- Example:\nBufferedReader reader = null;\nint total = 0;\ntry {\nreader =\nnew BufferedReader(new FileReader(""C:\Numbers.txt""));\nString line = null;\nwhile ((line = reader.readLine()) != null)\ntotal += Integer.valueOf(line);\nSystem.out.println(""Total: "" + total);\n} catch(Exception e) {\nSystem.out.println(e.getMessage());\n} finally {\ntry {\nif(reader != null)\nreader.close();\n} catch(Exception e) {\nSystem.out.println(e.getMessage());\n}\n}\n\nTwo useful functions for Exception e:\n1- e.getMessage() prints out the error message\n2- e.printStackTrace() prints out what it says on the stack that hopefully helps you understand what caused the error","Java Fundamentals: The Java Language","Exceptions and Error Handling","Error Handling with Exceptions","0:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=1&mode=live&start=1.926489&noteid=9d0fabd6-effd-41c2-b1bc-9859bcd1dbc6"
"Exception Class Hierarchy:\n- Object:\n  - Throwable\n   - Error: such as LinkageError, these are Virtual machine related errors (treated as unchecked exceptions)\n   - Exception\n     - RuntimeException\n       - such as NullPointerException, these are unchecked exceptions\n     - All other exceptions, such as IOException, are checked exceptions","Java Fundamentals: The Java Language","Exceptions and Error Handling","Handling Exceptions by Type","0:07","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=2&mode=live&start=7.167962&noteid=192c3fd2-81d4-4ef9-a70d-c5aacbfcbbaa"
"Checked exceptions: Exceptions that you MUST prepare for, otherwise the compiler won't compile your code.\n\nUnchecked exceptions: Exceptions that you CAN prepare for, but the compiler won't force you.","Java Fundamentals: The Java Language","Exceptions and Error Handling","Handling Exceptions by Type","2:58","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=2&mode=live&start=178.452939&noteid=3f005dd9-8c21-491e-a0ee-1930e347f295"
"Typed Exceptions:\n- Exceptions can be handled by type\n  - each exception type can have a SEPARATE catch block\n  - each catch is tested in order from top to bottom\n  - first assignable catch is selected, meaning that the catch block handles an exception that is either the type of exception thrown, or the base class of the type of exception thrown\n     - because a base class can satisfy the catch statement, we start catch blocks with the most specific exception types first and get more general as we go down\n     - use the type hierarchy to determine the order\n- Example:\nBufferedReader reader = null;\nint total = 0;\ntry {\n. . .\n} catch(NumberFormatException e) {\nSystem.out.println(Invalid value:  +\ne.getMessage());\n} catch(FileNotFoundException e) {\nSystem.out.println(Not found:  +\ne.getMessage());\n} catch(IOException e) {\nSystem.out.println(Error interacting with file:  +\ne.getMessage());\n} finally {\n. . .\n}","Java Fundamentals: The Java Language","Exceptions and Error Handling","Handling Exceptions by Type","3:00","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=2&mode=live&start=180.755056&noteid=6c6b0400-5226-45a0-85c2-549d0258d86e"
"Exceptions and Methods:\n- exceptions propagate up the call stack\n  - exceptions can cross method boundaries\n- in Java, exceptions that a method throws are part of that method's contract\n  - the method is responsible for any checked exceptions that might occur, and it has 2 choices for dealing with them:\n    - catch the exception\n    - document that the exception might occur by using the ""throws"" clause\n        - the throws clause lists any checked exceptions that might occur within that method that it doesn't handle\n- Example:\npublic class Flight {\nint passengers;\n// other members elided for clarity\npublic void addPassengers(String filename) throws IOException {\nBufferedReader reader = null;\ntry {\nreader = new BufferedReader(new FileReader(filename));\nString line = null;\nwhile ((line = reader.readLine()) != null) {\nString[] parts = line.split("" "");\npassengers += Integer.valueOf(parts[0]);\n}\n} finally {\nif(reader != null)\nreader.close();\n}\n}\n}\n\n- The above example of code is useful for when you want to take note of an exception and make sure that the code runs WITHOUT handling the exception itself, hence the try-finally block WITHOUT the catch block","Java Fundamentals: The Java Language","Exceptions and Error Handling","Exceptions and Methods","0:03","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=3&mode=live&start=3.175119&noteid=6f7c213e-64ac-4693-b39c-1f969934bf0d"
"Exceptions and Method Overriding:\n- the throws clause of an overriding method MUST be compatible with the throws clause of the overriden method\n- 3 ways to be compatible\n   - can exclude exceptions\n   - can have the same exception\n   - can have a derived exception\n       - Example: if base class threw IOException, derived class CAN throw FileNotFoundException, because FileNotFoundException is derived from IOException","Java Fundamentals: The Java Language","Exceptions and Error Handling","Exceptions and Methods","5:18","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=3&mode=live&start=318.45283&noteid=7a4a3fbb-6889-4895-ab10-b13860304149"
"Throwing Exceptions:\n- your code can throw exceptions\n  - use the ""throw"" keyword and then provide an instance of the exception we want to throw\n    - must create exception instance before throwing (using the new keyword)\n      - be sure to provide meaningful detail\n- Example: throw new InvalidStatementException(parameter-list);\n- most exception classes provide a constructor that accepts a String message or other detail\n- when caused by another exception, be sure to include the original exception\n  - all exception classes support the initCause method,which will allow you to associate an exception with an instance of another exception\n     - many exception classes provide a constructor that accepts the originating exception so you can actually create the new exception and associate the original all in one step\n- getCause function for exceptions returns the cause of this throwable or null if the cause is nonexistent or unknown.\n- Note: throwing a method but making sure that the previous method has to actually deal with it is possible as long as you include ""throws"" in the method header","Java Fundamentals: The Java Language","Exceptions and Error Handling","Throwing Exceptions and Custom Exceptions","0:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=4&mode=live&start=8.252157&noteid=c432cc47-8e69-4f12-bb60-4fbe1bb8527d"
"Creating a Custom Exception Type:\n- you can create your own custom exception types\n- in most cases it's better to use existing exception types\n- normally inherit directly from the Exception class\n  - makes them checked exceptions\n  -  the only members that your custom exception type will have will be constructors, because most of the required functionality is inherited\n- you will need to have at least 2 constructors:\n  - one constructor that accepts the required detail\n  - one constructor that accepts the required detail AND the originating exception\n- Example:\npublic class InvalidStatementException extends Exception {\n    public InvalidStatementException(String reason, String statement) {\n super(reason + "": "" + statement);\n    }\n\n    public InvalidStatementException(String reason, String statement, Throwable cause) {\n  super(reason + "": "" + statement, cause);\n    }\n\n}","Java Fundamentals: The Java Language","Exceptions and Error Handling","Throwing Exceptions and Custom Exceptions","1:51","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m10&clip=4&mode=live&start=111.691942&noteid=604ef18a-7c5c-4402-8b11-df18fc180f81"
"What is a package?\n- A package is a group of related types\n- By putting our types in packages, we get 3 core benefits:\n  - packages provide a namespace, that allow us to avoid type-naming collisions\n- packages provide an access boundary, a way to limit access to types and type-members\n- act as a unit of distribution, act as a way for us to distribute our types\n","Java Fundamentals: The Java Language","Working with Packages","What Is a Package?","0:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=1&mode=live&start=8.039921&noteid=f84b6eea-8803-45c0-a573-febfc5e340fb"
"Declaring Packages:\n- each source file identifies the associated package\n - use the ""package keyword""\n- package declaration must appear before any type declarations\n- once that package declaration (""package xxxx;""), any type that appears in that source file will now be part of that package, the package applies to all types within that source file","Java Fundamentals: The Java Language","Working with Packages","What Is a Package?","0:36","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=1&mode=live&start=36.415017&noteid=c0d8f899-3cd6-4af4-9803-662a757a2fad"
"Packages Create a Namespace:\n- package name is part of the type name\n- good for avoiding naming collisions\n- convention creates a unique package name\n  - follows reverse domain name structure\n    - if our domain is http://pluralsight.com -> package will be com.pluralsight, which is unique\n- type name now includes the package name/is qualified by the package name\n- Example:\npackage com.pluralsight.travel ;                 \npublic class Flight {\n// members elided for clarity\n}\n\n - Now declaring the variable works as follows:\ncom.pluralsight.travel. Flight lax175 =\nnew com.pluralsight.travel.Flight(175);\n  - having the package name be part of the type name is really useful for avoiding naming collisions","Java Fundamentals: The Java Language","Working with Packages","Packages Create a Namespace","0:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=2&mode=live&start=1.484067&noteid=53f50f16-d6ad-4bed-aa72-6b8c67fbed97"
"Determining a Type's Package:\n- the compiler needs to know each type's package\n- but explicitly qualifying each type is impractical, and would just cause long and complicated type declarations\n- Java offers several alternatives to explicitly qualifying types, which allows use of a type's simple name in our code:\n  - whenever you're working in a package, any types that you refer to that are part of that same package don't need to be qualified \n  - any types that are in the java.lang package do not to be qualified (such as Object, primitive wrapper classes, String, StringBuilder, etc)\n  - use type imports","Java Fundamentals: The Java Language","Working with Packages","Determining a Type's Package","0:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=3&mode=live&start=1.146519&noteid=0f3513a2-39c9-4058-a755-4c87de844074"
"Type Imports:\n- type imports guide the compiler to map simple names to qualified names\n  - done using the ""import"" keyword\n- Single Type Import:\n  - provides mapping for a single type\n  - Example: \nimport com.pluralsight.travel.Flight;\nimport com.xyzcompany.bar.Beer;\nimport com.pluralsight.travel.Passenger;\nimport com.xyzcompany.bar.Wine;\nFlight lax175 = new Flight(175);\nBeer liteBeer = new Beer();\nPassenger jane = new Passenger();\nWine merlot = new Wine();\n    - because we imported com.pluralsight.travel.Flight, the compiler knows that whenever we refer to the Flight class, we're referring to the Flight class as referred to in com.pluralsight.travel.Flight, and so only the declaration ""Flight lax175"" is required instead of the whole qualified name","Java Fundamentals: The Java Language","Working with Packages","Determining a Type's Package","1:27","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=3&mode=live&start=87.159261&noteid=263e891d-70bc-4c1f-8b83-3ba496d23289"
"Import on demand:\n- provides mapping for all types in a package\n- Example:\nimport com.pluralsight.travel .*;\nimport com.xyzcompany.bar .*;\npackage com.xyzcompany.bar;\nFlight lax175 = new Flight(175);\nBeer liteBeer = new Beer();\nPassenger jane = new Passenger();\nWine merlot = new Wine();\n  - using the ""*"" in ""import com.pluralsight.travel .*"" tells the compiler to map in ALL the types from the com.pluralsight.travel package, so during the compilation process, when the compiler sees the Flight declaration, it looks through all the packages imported to find the definition of the class called Flight\n- Note: it's an issue if two different packages that you're importing have the same name for a certain type (example Flight), and because you're using the ""*"" to import both packages, the compiler won't know which Flight class to use, and it''ll be a bug. Especially dangerous because it exposes code to potential breakage from changes in REFERENCED packages\n  - single type import, however, prevents that situation, and is therefore the preferred way to import types, because it is much safer (don't worry about typing too much, most modern IDEs will add your single type imports for you automatically)","Java Fundamentals: The Java Language","Working with Packages","Determining a Type's Package","4:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=3&mode=live&start=241.901306&noteid=b586f8f8-e19e-4174-8090-4ec6274f5cbc"
"Limiting Access to Package Content:\n- packages can serve as an access boundary\n  - often referred to as ""package private""\n- useful for creating types and features to support functionality provided by the package\n  -types and features are not meant to be used stand-alone\n- can apply this to an enter type/class\n  - entire type is inaccessible outside of the package\n- can apply to type/class members\n  - specific members of an otherwise accessible type are inaccessible outside of the package","Java Fundamentals: The Java Language","Working with Packages","Packages Provide Access Boundaries","0:06","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=4&mode=live&start=6.476163&noteid=3bf87459-c345-4734-8876-d166979b4f95"
"Access Modifiers:\n- No access modifier: visible only within its own package (aka package private), usable on both types and members\n- public: visible everywhere, usable on both types and members\n- private: visble only within its own class, usable on members and nested classes, but NOT top-level classes\n- protected: visible only within its own class and subclasses (the type itself and other types that inherit from it), usable on members and nested classes, but NOT top-level classes; can be used on ANY type that inherits from the class, whether its in the same package or not","Java Fundamentals: The Java Language","Working with Packages","Packages Provide Access Boundaries","1:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=4&mode=live&start=68.440601&noteid=f22ac94c-d435-44e4-a32a-4970068cda24"
"It's important to declare any types that we create that are meant only for use in our package as package private (no access modifier)","Java Fundamentals: The Java Language","Working with Packages","Separating CalcEngine into Packages","5:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=5&mode=live&start=302.220598&noteid=34ff5464-9a3d-4e1e-b4c0-983328df69e1"
"Make sure the IDE knows if you're changing the packages/adding new packages\n- In IntelliJ, Run->Edit Configurations helps you let the IDE know where everything is","Java Fundamentals: The Java Language","Working with Packages","Separating CalcEngine into Packages","6:29","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=5&mode=live&start=389.614038&noteid=4f8645b5-d6fc-4c0b-8574-06aed6fddd8b"
"Packages Provide a Unit of Distribution:\n- packages provide a predictable software structure, which simplifies distribution\n- class files are organized in hierarchical folders reflecting the package name\n  - each part of the package name is a separate folder\n  - Example:\npackage com.pluralsight.travel;\npublic class Flight {...}\n\nThe folder structure looks as follows:\ncom->pluralsight->travel>Flight.class","Java Fundamentals: The Java Language","Working with Packages","Packages Act as a Unit of Distribution","0:07","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=6&mode=live&start=7.688006&noteid=c71ca486-34c5-4f03-864c-6ce230075f58"
"Archive Files:\n- allow us to put that folder structure into an archive file\n  - these archive files are commonly known as JAR files\n- places the package folder structure into a SINGLE file, and that file can be optionally compressed\n- archive file can optionally include a manifest, which provides information regarding the archive content\n  - list of name-value pairs\n  - commonly used to identify the startup class that's contained in an archive file, making it easier for us to run a program that's inside an archive file","Java Fundamentals: The Java Language","Working with Packages","Packages Act as a Unit of Distribution","1:22","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=6&mode=live&start=82.194359&noteid=b8abd320-23e3-4339-9448-85da6fa90019"
"Creating Archive Files:\n- The JDK provides the jar command-line utility for creating archive files (check this link for how to create a JAR from the command line: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jar.html)\n- but the capability is included with many other tools:\n  - many IDEs have the ability built in\n  - many build automation systems (aka build managers) have the ability","Java Fundamentals: The Java Language","Working with Packages","Packages Act as a Unit of Distribution","3:01","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=6&mode=live&start=181.393094&noteid=6d762457-5afb-4b2f-8574-7aea9f5f6be2"
"META-INF folder contains the Manifest for the JAR file","Java Fundamentals: The Java Language","Working with Packages","Distributing CalcEngine as a Jar File","4:44","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=7&mode=live&start=284.073383&noteid=9f763e86-02e8-4e90-8d8d-438eec02ecab"
"Executing a JAR file:\n- Since the JAR file specifies what the entry point is (because the JAR file includes a manifest), you can run the JAR file (named CalcEngine in this case) using:\njava -jar CalcEngine.jar","Java Fundamentals: The Java Language","Working with Packages","Distributing CalcEngine as a Jar File","5:28","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m11&clip=7&mode=live&start=328.168091&noteid=a231b29a-4137-4739-be9c-bcb57adf46ee"
"What is an interface?\n- a skeleton class that contains method signatures with the fields but NO implementation\n  - but if you implement that interface, you can use the methods and implement them however you see fit\n- a interface is a type that defines a contract\n  - provides no implementation\n- classes implement interfaces\n  - expresses that the class conforms to the contract\n- It's a contract in that a class that implements an interface must implement all of the methods described in the interface, or be an abstract class.\n- interfaces don't limit the other aspects of the class' implementation\n- A Java interface is a bit like a class, except a Java interface can only contain method signatures and fields.\n- A Java interface cannot contain an implementation of the methods, only the signature (name, parameters and exceptions) of the method. \n- Example: given the Comparable interface and the Passenger class:\n""public class Passenger implements Comparable""\n- More complicated example:\npublic class Passenger implements Comparable {\n// others members elided for clarity\nprivate int memberLevel; // 3(1 st priority), 2, 1\nprivate int memberDays;\npublic int compareTo(Object o) {\nPassenger p = (Passenger) o;\nif(memberLevel > p.memberLevel)\nreturn -1;\nelse if(memberLevel < p.memberLevel)\nreturn 1;\nelse {\nif(memberDays > p.memberDays)\nreturn -1;\nelse if(memberDays < p.memberDays)\nreturn 1;\nelse\nreturn 0;\n} } }\n\nNow in the main:\n\nPassenger bob = new Passenger();\nbob.setLevelAndDays(1, 180);\nPassenger jane = new Passenger();\njane.setLevelAndDays(1, 90);\nPassenger steve = new Passenger();\nsteve.setLevelAndDays(2, 180);\nPassenger lisa = new Passenger();\nlisa.setLevelAndDays(3, 730);\nPassenger[] passengers =\n{bob, jane, steve, lisa};\nArrays.sort(passengers);\n\nNote that we can use Arrays.sort on the array of Passengers because we implemented the function that allows you to compare two Passengers to each other\n\nSorted Outcome: lisa, steve, bob, jane","Java Fundamentals: The Java Language","Creating Abstract Relationships with Interfaces","Introducing Interfaces & Implementing an Interface","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m12&clip=1&mode=live&start=2.527982&noteid=9b055e3d-3eec-45b4-b6e8-b591984eebe8"
"Implementing a Generic Interface\n- Some interfaces require additional type information\n- uses a concept known as generics\n- Note how the declaration for the Comparable interface looks as follows:\npublic interface Comparable<T> {\n}\nint compareTo(T o);\n}\n- instead of just using plain Comparable, where the compareTo method takes in an Object that we have to cast, we can instead implement Comparable<T>, where T is a specific type\n- So we can now do the following (and get rid of the casting requirement):\npublic class Flight implements Comparable <Flight> {\n// others members elided for clarity\nprivate int flightTime; // minutes past midnight\npublic int compareTo( Flight f ) {\nFlight f = (Flight) o;\nreturn flightTime - f.flightTime;\n- Note 1: when you implement the interface, the type (T) that you pass in DOES NOT have to be the same type as the class that's implementing it\n- Note 2: Generics are a general Java concept, it's not just for interfaces","Java Fundamentals: The Java Language","Creating Abstract Relationships with Interfaces","Implementing a Generic Interface","0:07","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m12&clip=2&mode=live&start=7.189036&noteid=d196a919-b73f-4a74-9187-bf3f31740100"
"Classes are free to implement MULTIPLE interfaces:\n- Note the Iterator interface and the Iterable interface:\n\npublic interface Iterable<T> {\nIterator<T> iterator();\n}\n\npublic interface Iterator<T> { \nboolean hasNext();\nT next();\n}\n\n- Big example:\npublic class Person {\n// other members elided for clarity\nprivate String name;\n} \n\npublic class CrewMember extends Person { \n// members elided for clarity\n}\n\n}\npublic class Passenger extends Person\nimplements Comparable<Passenger> {\n// members elided for clarity\n}\n\npublic class FlightIterator\nimplements Iterator<Person> {\n\nprivate CrewMember[] crew;\nprivate Passenger[] roster;\nprivate int index = 0;\n\npublic FlightIterator(\nCrewMember[] crew, Passenger[] roster) {\nthis.crew = crew;\nthis.roster = roster;\n}\n\nboolean hasNext() {\nreturn index < (crew.length + roster.length);\n}\n\npublic Person next() {\nPerson p = (index < crew.length) ?\ncrew[index] : roster[index  crew.length];\nindex++;\nreturn p;\n} }\n\n \npublic class Flight\nimplements Comparable<Flight>, Iterable<Person> {\n// others members elided for clarity\n \nprivate int flightTime;\nprivate CrewMember[] crew;\nprivate Passenger[] roster;\n \npublic int compareTo(Flight f) {\nFlight f = (Flight) o;\nreturn flightTime - f.flightTime;\n}\n \npublic Iterator<Person> iterator() {\nreturn new FlightIterator(crew, roster);\n}\n}\n\nMAIN METHOD:\n\nFlight lax045 = new Flight(45);\n// Add crew members:\n//\nPilot Patty, CoPilot Karl, Marshal Mary\n// Add Passengers:\n//\nBob, Jane, Steve, Lisa\nfor(Person p:lax045){\nSystem.out.println(p.getName());\n}\n\n- But wait, why isn't any of the iterator stuff being used here?\n- Actually, for-each loops use all the iterator stuff, you just don't see it!\n- What's actually going on during the \n\nfor(Person p:lax045){\nSystem.out.println(p.getName());\n}\n\nis as follows:\n\nIterable<Person> laxIterable = lax045;\nIterator<Person> persons = laxIterable.iterator();\nwhile(persons.hasNext()) {\nPerson p = persons.next();\nSystem.out.println(p.getName());\n}\n","Java Fundamentals: The Java Language","Creating Abstract Relationships with Interfaces","Implementing Multiple Interfaces","0:08","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m12&clip=3&mode=live&start=8.449625&noteid=b48a4d73-e2e6-4ca0-a115-9b38252d7655"
"Declaring an Interace:\n- similar to declaring a class\n  - use the ""interface"" keyword, so ""public interface MathProcessing""\n- interfaces support a subset of the features available to classes\n  - can have methods, but only contains the name, parameters, and return type, and the methods are implictly public\n  - can have constants, that is a type named value, and the constants are implicitly public, final, and static, which means that any constant you associate with an interface has the same value for all implementors of the interface\n- an interface can extend another interface, and implementing an extended interface implies implementation of the base interface","Java Fundamentals: The Java Language","Creating Abstract Relationships with Interfaces","Declaring an Interface","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m12&clip=4&mode=live&start=2.079035&noteid=d4c4ad4f-a505-4eaa-aa9c-eda87c011b94"
"Static Members:\n- instance members: each class member is associated with a specific class instance (what we usually want)\n- static members are shared class-wide (global variable)\n- a static member is a member that is not associated with any individual instance\n- declared just like any other variable/method, but with the word ""static"" in front of it\n- static members are stored SEPARATELY from any instance\n- because static members are not associated with any individual instance, you can actually access them using the class name\n- static field: a value that is not associated with a specific instance, meaning that all instances will access the same value for that field\n- static method: performs an action not tied to a specific instance, and can only access static fields and not any instance fields because they're not associated with an individual instance\n- Example:\n\nclass Flight {\n// other members elided for clarity\nint passengers;\nvoid add1Passenger() {\nif(hasSeating()) {\npassengers += 1;\nallPassengers += 1;\n} else\nhandleTooMany();\n}\nstatic int allPassengers;\nstatic int getAllPassengers() {\nreturn allPassengers;\n}\nstatic int resetAllPassengers() {\nallPassengers = 0;\n}\n\nMain Method:\n\nFlight.resetAllPassengers();\nSystem.out.println(\nFlight.getAllPassengers());\nFlight lax045 = new Flight();\nlax045.add1Passenger();\nlax045.add1Passenger();\nFlight slc015 = new Flight();\nslc015.add1Passenger();\nSystem.out.println(\nFlight.getAllPassengers());\n\n- Notice how the getAllPassengers method & resetAllPassengers method are accessed with a ""Flight."" in front as opposed to an instance name, because they are static and are therefore stored separately from any instance","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Static Members","0:10","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=1&mode=live&start=10.134891&noteid=ee40dd82-2083-4d57-a621-be1d42738c0c"
"Static Import:\n- provides shorthand for accessing static members (without even using the classname)\n- Example:\n\nimport static com.pluralsight.travel.Flight .resetAllPassengers;\nimport static com.pluralsight.travel.Flight .getAllPassengers;\nFlight. resetAllPassengers();\nSystem.out.println(\nFlight. getAllPassengers());\nFlight lax045 = new Flight();\nlax045.add1Passenger();\nlax045.add1Passenger();\nFlight slc015 = new Flight();\nslc015.add1Passenger();\nSystem.out.println(\nFlight. getAllPassengers());\n\n- Because we imported com ... resetAllPassengers and\ncom ... getAllPassengers, we can simply call the methods by their name now without having to include the class name in front, as you can see above","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Static Members","4:36","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=1&mode=live&start=276.939327&noteid=d021bacc-f3bc-4b59-8023-e2fe51f9d9b4"
"Static Initialization Blocks\n- instance initialization blocks: automatically execute before any of your constructors\n- perform one-time type initialization\n - executed BEFORE the type's FIRST use\n -  think of them as type initializers\n- statements enclosed in brackets outside of any method or constructor, but preceded with the ""static"" keyword\n- CANNOT access any instance members, only static members\n- must handle all checked exceptions within the initialization block (can't use throws keyword)","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Static Initialization Blocks","0:00","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=2&mode=live&start=0.686871&noteid=54f1672f-6df6-45ea-8740-ef7a869c01cc"
"Nested Types:\n- a type declared within another type\n  - classes can be declared within classes and interfaces\n  - interfaces can be declared within classes and interfaces\n- when you nest a type inside another, the nested type becomes a member of the enclosing type\n  - private members of the enclosing type are visible to the nested type\n- nested types support all member access modifiers\n  - can be public, package private, package private, or private\n- Nested types serve different purposes","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Nested Types","0:02","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=3&mode=live&start=2.207378&noteid=e9bcc63b-e172-405a-9e5f-d12de6daa914"
"Nested Type Purpose #1: Structure & Scoping:\n- Structure and scoping:\n   - no relationship between instances of nested and enclosing type\n   - Happens when:\n     - static classes nested within classes\n     - all classes nested within interfaces\n     - all nested interfaces\n   - Example:\npublic class Passenger implements Comparable {\n// others members elided for clarity\npublic static class RewardProgram {\nprivate int memberLevel;\nprivate int memberDays;\npublic int getLevel() { return level; }\npublic void setLevel(int level) { this.level = level; }\n}\npublic int getMemberDays() { return memberDays; }\npublic void setMemberDays(int days) { this.memberDays = days; }\nprivate RewardProgram rewardProgram = new RewardProgram();\n}\npublic RewardProgram getRewardProgram() {\nreturn rewardProgram;\n}\nMain Method: \nPassenger steve = new Passenger();\nsteve.setName(""Steve"");\nsteve.getRewardProgram() .setLevel(3);\nsteve.getRewardProgram().setMemberDays(180);\nPassenger.RewardProgram platinum = new Passenger.RewardProgram();\nplatinum.setLevel(3);\nif(steve.getRewardProgram().getLevel() == platinum.getLevel())\nSystem.out.println(""Steve is platinum"");\n  - Note: if declared as public, the nested class can be used separately from the enclosing class, except when you declare it, you say ""enclosingclass.nestedclass = new enclosingclass.nestedclass();""","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Inner Classes","0:14","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=4&mode=live&start=14.837123&noteid=c4a0a8bb-89a5-4338-b7cc-4c2906eba821"
"Nested Type Purpose #2: Inner Classes:\n- each instance of the nested class is associated with an instance of the enclosing class\n- Happens when:\n  - NON-static classes nested within classes\n- Example:\n \npublic class Flight\nimplements Comparable<Flight>, Iterable<Person> {\n// others members elided for clarity\nprivate CrewMember[] crew;\nprivate Passenger[] roster;\npublic Iterator<Person> iterator() {\nreturn new FlightIterator();\n}\nprivate class FlightIterator\nimplements Iterator<Person> {\nFlight.this\nthis\n}\nprivate int index = 0;\npublic boolean hasNext() {\nreturn index < (crew.length + roster.length);\n}\npublic Person next() {\nPerson p = (index < crew.length) ?\ncrew[index] : roster[index  crew.length];\nindex++;\nreturn p;\n}\n}\n\n- By simply declaring FlightIterator as a NON-static class nested inside another class, each time we create an instance of FlightIterator, that FlightIterator instance is automatically associated with the instance of the Flight class in which it was created.","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Inner Classes","0:14","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=4&mode=live&start=14.837123&noteid=d63e5f77-deed-41a3-bc7e-243303bea90b"
"Anonymous Classes:\n- allow us to avoid the need to declare a bunch of classes and give them names that we're only going to use in one place\n- with anonymous classes, we're able to declare our class as part of the class' creation\n  - useful for simple interface implementations or class extensions, useful for solving a particular problem\n- anonymous classes are INNER classes\n  - an anonymous instance is associated with the containing class instance\n- we create an anonymous class as if we're constructing an instance of the interface or base class that we want to extend\n  - place opening and closing brackets after the interface or base class\n  - place implementation code within the brackets\n- Example:\n  - in this example, we're simply declaring the FlightIterator class as an anonymous class because we only use it in the Flight class\n\npublic class Flight\nimplements Comparable<Flight>, Iterable<Person> {\n// others members elided for clarity\nprivate CrewMember[] crew;\nprivate Passenger[] roster;\npublic Iterator<Person> iterator() {\nreturn new Iterator<Person>() {\nprivate int index = 0;\npublic boolean hasNext() {\nreturn index < (crew.length + roster.length);\n}\npublic Person next() {\nPerson p = (index < crew.length) ?\ncrew[index] : roster[index  crew.length];\n}\n}\n}\n}\nindex++;\nreturn p;","Java Fundamentals: The Java Language","Static Members, Nested Types, and Anonymous Classes","Anonymous Classes","0:05","https://app.pluralsight.com/player?course=java-fundamentals-language&author=jim-wilson&name=java-fundamentals-language-m13&clip=5&mode=live&start=5.46991&noteid=93c5598c-0b6b-4b79-9ee6-7ec95ad38190"